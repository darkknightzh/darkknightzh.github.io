<!DOCTYPE html><html lang="en-US" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="SSD Single Shot MultiBox Detector" /><meta name="author" content="darkknightzh" /><meta property="og:locale" content="en_US" /><meta name="description" content="仅供学习交流使用，错误之处在所难免，欢迎指正." /><meta property="og:description" content="仅供学习交流使用，错误之处在所难免，欢迎指正." /><link rel="canonical" href="https://darkknightzh.github.io/posts/SSD/" /><meta property="og:url" content="https://darkknightzh.github.io/posts/SSD/" /><meta property="og:site_name" content="darkknightzh" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-23T16:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="SSD Single Shot MultiBox Detector" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"darkknightzh"},"dateModified":"2021-09-23T16:21:31+08:00","datePublished":"2021-08-23T16:00:00+08:00","description":"仅供学习交流使用，错误之处在所难免，欢迎指正.","headline":"SSD Single Shot MultiBox Detector","mainEntityOfPage":{"@type":"WebPage","@id":"https://darkknightzh.github.io/posts/SSD/"},"url":"https://darkknightzh.github.io/posts/SSD/"}</script><title>SSD Single Shot MultiBox Detector | darkknightzh</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] }, // chtml: { displayAlign: 'left' } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">darkknightzh</a></div><div class="site-subtitle font-italic">忘记一个人，从忘记那个声音开始</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>主页</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>时间轴</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/darkknightzh" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>SSD Single Shot MultiBox Detector</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>SSD Single Shot MultiBox Detector</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> darkknightzh </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Aug 23, 2021, 4:00 PM +0800" prep="on" > Aug 23, 2021 <i class="unloaded">2021-08-23T16:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Sep 23, 2021, 4:21 PM +0800" prefix="Updated " > Sep 23, 2021 <i class="unloaded">2021-09-23T16:21:31+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="17166 words">95 min</span></div></div><div class="post-content"><style> h1 { border-bottom: none }</style><p>转载请注明出处：</p><p><a href="https://darkknightzh.github.io/posts/SSD">https://darkknightzh.github.io/posts/SSD</a></p><p>论文：</p><p><a href="https://arxiv.org/abs/1512.02325">https://arxiv.org/abs/1512.02325</a></p><p>第三方pytorch代码：</p><p><a href="https://github.com/amdegroot/ssd.pytorch">https://github.com/amdegroot/ssd.pytorch</a></p><h2 id="p1-简介">P1. 简介</h2><p>SSD（Single Shot MultiBox Detector）由W. Liu等人于2015年提出，比之前的SOTA的一阶段的检测算法YOLO更快，切更准确，同时和二阶段的检测算法，如Faster R-CNN准确度相近。</p><p>它相比起YOLO v1 主要的改进点在于两个方面：1. 利用了先验框（Prior Box）的方法，预先给定缩放倍数和宽高比。2. 多尺度（multi-scale）预测，即对CNN 输出的后面的多个不同尺度的特征图都进行预测。</p><ul><li><p>SSD和核心是在特征图上使用小的卷积核，对固定数量的默认框，预测相应的目标类别的分数和目标框偏移。</p><li><p>为了检测精度，使用多尺度对及不同比例来监测目标。</p><li><p>端到端训练，即便在低分辨率图像上也能获得比较好的性能，进一步提高了速度和准确率之间的平衡。</p><li><p>实验结果好。</p></ul><p>如图1，狗的尺寸较大，因此用到了更靠后的feature map（越靠后所代表的原图中的比例越大），而猫的尺寸较小，用的是前面的feature map。同时，还要适配各自的长宽比。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/post/2021-08-23-SSD/1ssd.png" alt="1" /> <em>图1 ssd结构（a）训练阶段SSD只需要输入图像和每个目标的真值框。不同尺度（如b中的8*8和c中的4*4）不同分辨率上每个位置不同长宽比默认框。每个默认框，预测形状偏移和所有目标的得分（ \(\left( { {c}_{1}},{ {c}_{2}},\cdots ,{ {c}_{p}} \right)\) ）。训练阶段，先将这些默认框和GT框匹配。例如，已经将两个默认框匹配到了猫，一个默认框匹配到了狗（由于目标大小不同，因而可能在不同分辨率上匹配到的），这些框被看成正样本，其他框则是负样本。模型使用定位损失（如Smooth L1）和置信损失（如Softmax）的加权和。</em></p><p>说明：默认框：default boxes 。GT框：ground truth boxes</p><h2 id="p2-ssd">P2. SSD</h2><h3 id="p21-模型">P2.1 模型</h3><p>SSD主要包括骨干网络和额外的网络结构。</p><p><strong>多尺度特征图</strong>：骨干网络：截断的VGG16到Conv5_3层。在截断的VGG16之后加上了一些卷积层，作为多尺度特征图。</p><p><strong>卷积预测</strong>：在VGG16之后增加的每个卷积层，都能得到固定数量的检测结果。如图2中SSD结构的右侧。对于p通道的m*n大小的特征层，通过3*3*p的小的卷积核可以在每个m*n的位置预测分类的分数及和默认框坐标的偏移。</p><p>多尺度特征图作为特征金字塔，好处如下：① 特征层越高，具有的语义信息越丰富，充分利用不同级别的特征，要优于只在最后一层进行检测效果。② 特征层从低到高，感受野由小到大，可用于检测不同尺寸的目标。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/post/2021-08-23-SSD/2compare.png" alt="2" /> <em>图2</em></p><p><strong>默认框和长宽比</strong>：将一系列默认边界框和每个特征图单元关联，因而每个默认框和相应的特征图单元的位置是固定的。在每个特征图单元上，预测和默认框的偏移，以及每个类别的分数。具体来说，对于每个位置中的k个框（k是每个位置有不同纵横比，所以有k个框），分别计算c个类别得分和4个和默认框的坐标偏移，这样m*n的特征图上的每个位置共(c+4)kmn个输出。如图1对默认框进行了解释。默认框类似于Faster R-CNN中的anchor boxes，不过本文将默认框应用到不同分辨率的特征图上。</p><h3 id="p22-训练">P2.2 训练</h3><p>训练包括选择用于检测的尺度和默认框的集合，以及难例挖掘和数据扰动策略。</p><p><strong>匹配策略</strong>：训练阶段需要确定哪个默认框对应一个GT框并训练模型。对于每个gt box，本文选择随着位置、比例、尺度上而变换的多个default box。具体匹配策略：先将IoU最高的GT框匹配给默认框，这样保证每一个GT框与唯一的一个默认框对应起来。而后将IoU超过阈值0.5的默认框匹配到GT框。这种方式可以简化训练问题，允许网络对于和GT框重叠的多个默认框都可以预测到比较高的分值，而不必强制最大重叠的预测高分值</p><p><strong>损失函数</strong>：令 \(x_{ij}^{p}=\left\{ 0,1 \right\}\) 代表第i个默认框和第j个GT框的第p个类别是否匹配的标志。通过以上的匹配策略， \(\sum\limits_{i}{x_{ij}^{p}}\ge 1\) （对于第j个GT框，一定分配了至少1个默认框）。模型使用定位损失（loc）和分类损失（conf）的加权和：</p>\[L\left( x,c,l,g \right)=\frac{1}{N}\left( { {L}_{conf}}\left( x,c \right)+\alpha { {L}_{Loc}}\left( x,l,g \right) \right) \tag{1}\]<p>其中N为匹配到的默认框的数量。如果N=0，设置损失为0。 \(\alpha\) 为权重，通过交叉验证，设置为1。定位损失为预测框（l）和GT框（g）之间的Smooth L1 loss。和FasterR-CNN类似，本文和默认框（d）的中心偏移（cx，cy）和宽（w）高（h）。</p>\[\begin{align} &amp; { {L}_{Loc}}\left( x,l,g \right)=\sum\limits_{i\in Pos}^{N}{\sum\limits_{m\in \left\{ cx,cy,w,h \right\}}{x_{ij}^{k}smoot{ {h}_{L1}}\left( l_{i}^{m}-\hat{g}_{j}^{m} \right)}} \\ &amp; \hat{g}_{j}^{cx}=\left( g_{j}^{cx}-d_{i}^{cx} \right)/d_{i}^{w} \quad \quad \quad\hat{g}_{j}^{cy}=\left( g_{j}^{cy}-d_{i}^{cy} \right)/d_{i}^{h} \\ &amp; \hat{g}_{j}^{w}=\log \left( \frac{g_{j}^{w}}{d_{i}^{w}} \right) \quad \quad \quad \quad\quad \hat{g}_{j}^{h}=\log \left( \frac{g_{j}^{h}}{d_{i}^{h}} \right) \\ \end{align} \tag{2}\]<p>其中g为GT框，d为默认框， \(\hat{g}\) 为GT框和默认框的偏移，l为预测框。此处为拟合坐标偏移，即l为拟合的坐标偏移，期望预测的坐标偏移和实际的坐标偏移尽可能接近。</p><p>置信度损失为多类别的Softmax loss（c）：</p>\[{ {L}_{conf}}\left( x,c \right)=-\sum\limits_{i\in Pos}^{N}{x_{ij}^{p}\log \left( \hat{c}_{i}^{p} \right)}-\sum\limits_{i\in Neg}{\log \left( \hat{c}_{i}^{0} \right)},\text{ }\hat{c}_{i}^{p}=\frac{\exp \left( c_{i}^{p} \right)}{\sum\nolimits_{p}{\exp \left( c_{i}^{p} \right)}} \tag{3}\]<p><strong>对默认框选择尺度和长宽比</strong>：本文使用低层和高层特征进行检测。图1显示了算法中用到的2个特征图（8*8和4*4），实际上会使用更多特征图。</p><p>不同层的特征图有不同的感受野。假定要使用m个特征图用于预测，则每个特征图上默认框的尺度如下：</p>\[{ {s}_{k}}={ {s}_{\min }}+\frac{ { {s}_{\max }}-{ {s}_{\min }}}{m-1}\left( k-1 \right),\text{ k}\in \left[ 1,m \right] \tag{4}\]<p>其中 \({ {s}_{\min }}=0.2\) ， \({ {s}_{\max }}=0.9\) ，代表着最低层缩放0.2倍，最高层特征缩放0.9倍（此处指不同层默认框缩放不同倍数。最低层特征图较大，缩放倍数更小，更易于检测小目标；最高层特征图较小，缩放更倍数大，不会使得缩放后目标太小），中间层进行相应的归一化。使用不同宽高比的默认框，如 \({ {a}_{r}}=\left\{ 1,2,3,\frac{1}{2},\frac{1}{3} \right\}\) 。可以计算每个默认框相应的宽（ \(w_{k}^{a}={ {s}_{k}}\sqrt{ { {a}_{r}}}\) ）和高（ \(h_{k}^{a}={ { {s}_{k}}}/{\sqrt{ { {a}_{r}}}}\;\) ）。对于宽高比为1的默认框，额外增加一个缩放倍数为 \(s_{k}^{'}=\sqrt{ { {s}_{k}}{ {s}_{k+1}}}\) 的默认框，因而特征图每个位置共6个默认框。每个默认框的中心设置为 \(\left( \frac{i+0.5}{\left| { {f}_{k}} \right|}\frac{j+0.5}{\left| { {f}_{k}} \right|} \right)\) ，其中 \(\left| { {f}_{k}} \right|\) 为第k个正方形特征图的大小， \(i,j\in \left[ 0,\left| { {f}_{k}} \right| \right)\) 。当然也可以根据实际数据库设计默认框。</p><p>通过结合不同特征图上所有位置不同尺度和不同宽高比的所有默认框，可以得到各种各样的预测，能否覆盖各种各样目标的大小和形状。如图1中，狗在4*4特征图上匹配到了默认框，但是在8*8特征图上没有匹配到任何默认框。因而训练阶段在8*8特征图上被认定为负样本。</p><p><strong>难例挖掘</strong>：匹配策略之后，大部分默认框都为负样本，切负样本数量很高。导致训练阶段正负样本不均衡。本文对每个默认框的置信度进行排序，并使用最高的置信度，确保正负样本比例为1:3。这样能更快收敛，且训练更稳定。</p><p><strong>数据扰动</strong>：为了是模型对不同大小和形状的目标更稳健，每张训练图像通过一下方式随机采样：</p><p>① 使用整张原始图像</p><p>② 使用图像的一个子块，保证目标和子块最小的IoU为0.1,0.3,0.5,0.7,0.9</p><p>③ 随机采样一个子块</p><p>采样的子块大小是原始图像大小的[0.1, 1]倍之间，采样宽高比为0.5到2之间。经过以上步骤之后，每个子块缩放到固定大小，并且以0.5的概率水平翻转，并使用<a href="https://arxiv.org/abs/1312.5402">https://arxiv.org/abs/1312.5402</a>中的一些图像调整方法。</p><p><strong>注意</strong>：训练阶段会滤除和gt box的IoU小于阈值的，将这些设置为背景。而后难例挖掘，不会进行nms。难例挖掘时，先得到正样本数量，而后通过对预测的负样本概率进行排序，得到概率较大的，同时保证正负样本比例为1:3，使用这些正负样本计算分类损失。另一方面，只对正样本计算定位损失。</p><p>测试阶段对检测结果进行nms，去除太近的框。</p><h2 id="p3-代码">P3. 代码</h2><h3 id="p31-训练">P3.1 训练</h3><p>训练代码位于train.py。</p><h4 id="p311-train">P3.1.1 train</h4><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">train</span><span class="p">():</span>
    <span class="c1"># 训练阶段只会滤除和gt box的IoU小于阈值的，将这些设置为背景。而后难例挖掘，不会进行nms
</span>    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">dataset</span> <span class="o">==</span> <span class="sh">'</span><span class="s">COCO</span><span class="sh">'</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1"># if args.dataset_root == VOC_ROOT:     # 避免设置错误，给出提示
</span>        <span class="c1">#     if not os.path.exists(COCO_ROOT):
</span>        <span class="c1">#         parser.error('Must specify dataset_root if specifying dataset')
</span>        <span class="c1">#     print("WARNING: Using default COCO dataset_root because " +
</span>        <span class="c1">#           "--dataset_root was not specified.")
</span>        <span class="c1">#     args.dataset_root = COCO_ROOT
</span>        <span class="c1"># cfg = coco
</span>        <span class="c1"># dataset = COCODetection(root=args.dataset_root,
</span>        <span class="c1">#                         transform=SSDAugmentation(cfg['min_dim'], MEANS))      # 得到COCO的信息，供DataLoader使用
</span>    <span class="k">elif</span> <span class="n">args</span><span class="p">.</span><span class="n">dataset</span> <span class="o">==</span> <span class="sh">'</span><span class="s">VOC</span><span class="sh">'</span><span class="p">:</span>             <span class="c1"># 避免设置错误，给出提示
</span>        <span class="c1"># if args.dataset_root == COCO_ROOT:
</span>        <span class="c1">#     parser.error('Must specify dataset if specifying dataset_root')
</span>        <span class="n">cfg</span> <span class="o">=</span> <span class="n">voc</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="nc">VOCDetection</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">args</span><span class="p">.</span><span class="n">dataset_root</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="nc">SSDAugmentation</span><span class="p">(</span><span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">min_dim</span><span class="sh">'</span><span class="p">],</span> <span class="n">MEANS</span><span class="p">))</span>   <span class="c1"># 得到voc的信息，供DataLoader使用
</span>
    <span class="c1"># if args.visdom:
</span>    <span class="c1">#     import visdom
</span>    <span class="c1">#     viz = visdom.Visdom()   # loss的可视化
</span>
    <span class="n">ssd_net</span> <span class="o">=</span> <span class="nf">build_ssd</span><span class="p">(</span><span class="sh">'</span><span class="s">train</span><span class="sh">'</span><span class="p">,</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">min_dim</span><span class="sh">'</span><span class="p">],</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">num_classes</span><span class="sh">'</span><span class="p">])</span>   <span class="c1"># 得到训练时的ssd多分辨率检测网络
</span>    <span class="n">net</span> <span class="o">=</span> <span class="n">ssd_net</span>

    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">cuda</span><span class="p">:</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">DataParallel</span><span class="p">(</span><span class="n">ssd_net</span><span class="p">)</span>
        <span class="n">cudnn</span><span class="p">.</span><span class="n">benchmark</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">resume</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Resuming training, loading {}...</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">resume</span><span class="p">))</span>
        <span class="n">ssd_net</span><span class="p">.</span><span class="nf">load_weights</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">resume</span><span class="p">)</span>       <span class="c1"># load之前训练的权重
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="n">vgg_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">save_folder</span> <span class="o">+</span> <span class="n">args</span><span class="p">.</span><span class="n">basenet</span><span class="p">)</span>    <span class="c1"># load预训练的vgg模型
</span>        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Loading base network...</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">ssd_net</span><span class="p">.</span><span class="n">vgg</span><span class="p">.</span><span class="nf">load_state_dict</span><span class="p">(</span><span class="n">vgg_weights</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">cuda</span><span class="p">:</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">.</span><span class="nf">cuda</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">.</span><span class="n">resume</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Initializing weights...</span><span class="sh">'</span><span class="p">)</span>
        <span class="c1"># initialize newly added layers' weights with xavier method
</span>        <span class="n">ssd_net</span><span class="p">.</span><span class="n">extras</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">weights_init</span><span class="p">)</span>         <span class="c1"># extras部分conv的参数初始化  extra layers that feed to multibox loc and conf layers
</span>        <span class="n">ssd_net</span><span class="p">.</span><span class="n">loc</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">weights_init</span><span class="p">)</span>            <span class="c1"># loc部分conv的参数初始化  localization layers
</span>        <span class="n">ssd_net</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="n">weights_init</span><span class="p">)</span>           <span class="c1"># conf部分conv的参数初始化  confidence layers
</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="p">.</span><span class="nc">SGD</span><span class="p">(</span><span class="n">net</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">args</span><span class="p">.</span><span class="n">lr</span><span class="p">,</span> <span class="n">momentum</span><span class="o">=</span><span class="n">args</span><span class="p">.</span><span class="n">momentum</span><span class="p">,</span> <span class="n">weight_decay</span><span class="o">=</span><span class="n">args</span><span class="p">.</span><span class="n">weight_decay</span><span class="p">)</span>
    <span class="n">criterion</span> <span class="o">=</span> <span class="nc">MultiBoxLoss</span><span class="p">(</span><span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">num_classes</span><span class="sh">'</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">cuda</span><span class="p">)</span>    <span class="c1"># 计算loss  # 训练阶段只会滤除和gt box的IoU小于阈值的，讲这些设置为背景。而后难例挖掘，不会进行nms
</span>
    <span class="n">net</span><span class="p">.</span><span class="nf">train</span><span class="p">()</span>
    <span class="c1"># loss counters
</span>    <span class="n">loc_loss</span> <span class="o">=</span> <span class="mi">0</span>        <span class="c1"># 得到的检测框的定位误差
</span>    <span class="n">conf_loss</span> <span class="o">=</span> <span class="mi">0</span>       <span class="c1"># 得到的检测框的分类误差
</span>    <span class="n">epoch</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Loading the dataset...</span><span class="sh">'</span><span class="p">)</span>

    <span class="n">epoch_size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">//</span> <span class="n">args</span><span class="p">.</span><span class="n">batch_size</span>    <span class="c1"># 每个epoch的训练次数
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Training SSD on:</span><span class="sh">'</span><span class="p">,</span> <span class="n">dataset</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Using the specified args:</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="n">step_index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># if args.visdom:    # 可视化相关的初始化
</span>    <span class="c1">#     vis_title = 'SSD.PyTorch on ' + dataset.name
</span>    <span class="c1">#     vis_legend = ['Loc Loss', 'Conf Loss', 'Total Loss']
</span>    <span class="c1">#     iter_plot = create_vis_plot('Iteration', 'Loss', vis_title, vis_legend)
</span>    <span class="c1">#     epoch_plot = create_vis_plot('Epoch', 'Loss', vis_title, vis_legend)
</span>
    <span class="n">data_loader</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nc">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="n">args</span><span class="p">.</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">collate_fn</span><span class="o">=</span><span class="n">detection_collate</span><span class="p">,</span> <span class="n">pin_memory</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c1"># create batch iterator
</span>    <span class="n">batch_iterator</span> <span class="o">=</span> <span class="nf">iter</span><span class="p">(</span><span class="n">data_loader</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">start_iter</span><span class="p">,</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">max_iter</span><span class="sh">'</span><span class="p">]):</span>
        <span class="c1"># if args.visdom and iteration != 0 and (iteration % epoch_size == 0):
</span>        <span class="c1">#     update_vis_plot(epoch, loc_loss, conf_loss, epoch_plot, None, 'append', epoch_size)   # 每训练一个epoch，更新一下显示结果
</span>        <span class="c1">#     # reset epoch loss counters  重置相关参数
</span>        <span class="c1">#     loc_loss = 0
</span>        <span class="c1">#     conf_loss = 0
</span>        <span class="c1">#     epoch += 1
</span>
        <span class="k">if</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">lr_steps</span><span class="sh">'</span><span class="p">]:</span>
            <span class="n">step_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nf">adjust_learning_rate</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">gamma</span><span class="p">,</span> <span class="n">step_index</span><span class="p">)</span>   <span class="c1"># 调整lr
</span>
        <span class="c1"># load train data
</span>        <span class="n">images</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">batch_iterator</span><span class="p">)</span>   <span class="c1"># 得到下一组数据（图像，bbox+label），图像为B*C*300*300，bbox+label为B个tensor，每个tensor为ki*5矩阵（ki为当前图像SSDAugmentation之后目标数量，实际不会太多）
</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">cuda</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="nc">Variable</span><span class="p">(</span><span class="n">images</span><span class="p">.</span><span class="nf">cuda</span><span class="p">())</span>
            <span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Variable</span><span class="p">(</span><span class="n">ann</span><span class="p">.</span><span class="nf">cuda</span><span class="p">(),</span> <span class="n">volatile</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">]</span>   <span class="c1"># 类别、bbox+label
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="nc">Variable</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
            <span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Variable</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">volatile</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">]</span>   <span class="c1"># 类别、bbox+label
</span>        <span class="c1"># forward
</span>        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nf">net</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>   <span class="c1"># 得到图像通过网络的输出    # 预测的bs*N*4的密集坐标（预测的偏移） + 预测的bs*N*num_classes的密集分类结果 + 不同分辨率的密集先验坐标（输入图像宽高一样，因而共用先验坐标即可）：N*4。N个[cx, cy, w, h]
</span>        <span class="c1"># backprop
</span>        <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
        <span class="n">loss_l</span><span class="p">,</span> <span class="n">loss_c</span> <span class="o">=</span> <span class="nf">criterion</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span>   <span class="c1"># 通过网络，计算定位误差和分类误差
</span>        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_l</span> <span class="o">+</span> <span class="n">loss_c</span>   <span class="c1"># 总损失
</span>        <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="c1"># loc_loss += loss_l.data[0]    # 累计定位误差
</span>        <span class="c1"># conf_loss += loss_c.data[0]   # 累计分类误差
</span>        <span class="n">loc_loss</span> <span class="o">+=</span> <span class="n">loss_l</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span>    <span class="c1"># 累计定位误差
</span>        <span class="n">conf_loss</span> <span class="o">+=</span> <span class="n">loss_c</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span>   <span class="c1"># 累计分类误差
</span>
        <span class="k">if</span> <span class="n">iteration</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">timer: %.4f sec.</span><span class="sh">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="p">))</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">iter </span><span class="sh">'</span> <span class="o">+</span> <span class="nf">repr</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span> <span class="o">+</span> <span class="sh">'</span><span class="s"> || Loss: %.4f ||</span><span class="sh">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()),</span> <span class="n">end</span><span class="o">=</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">)</span>

        <span class="c1"># if args.visdom:
</span>        <span class="c1">#     update_vis_plot(iteration, loss_l.data[0], loss_c.data[0],
</span>        <span class="c1">#                     iter_plot, epoch_plot, 'append')
</span>
        <span class="k">if</span> <span class="n">iteration</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">iteration</span> <span class="o">%</span> <span class="mi">5000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Saving state, iter:</span><span class="sh">'</span><span class="p">,</span> <span class="n">iteration</span><span class="p">)</span>
            <span class="n">torch</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">ssd_net</span><span class="p">.</span><span class="nf">state_dict</span><span class="p">(),</span> <span class="sh">'</span><span class="s">weights/ssd300_COCO_</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">repr</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span> <span class="o">+</span> <span class="sh">'</span><span class="s">.pth</span><span class="sh">'</span><span class="p">)</span>       <span class="c1"># 保存训练的参数
</span>    <span class="n">torch</span><span class="p">.</span><span class="nf">save</span><span class="p">(</span><span class="n">ssd_net</span><span class="p">.</span><span class="nf">state_dict</span><span class="p">(),</span> <span class="n">args</span><span class="p">.</span><span class="n">save_folder</span> <span class="o">+</span> <span class="sh">''</span> <span class="o">+</span> <span class="n">args</span><span class="p">.</span><span class="n">dataset</span> <span class="o">+</span> <span class="sh">'</span><span class="s">.pth</span><span class="sh">'</span><span class="p">)</span>
</pre></table></code></div></div></details><h4 id="p312-adjust_learning_rate">P3.1.2 adjust_learning_rate</h4><p>调整lr代码如下：</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">adjust_learning_rate</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>   <span class="c1"># 调整lr
</span>    <span class="sh">"""</span><span class="s">Sets the learning rate to the initial LR decayed by 10 at every
        specified step
    # Adapted from PyTorch Imagenet example:
    # https://github.com/pytorch/examples/blob/master/imagenet/main.py
    </span><span class="sh">"""</span>
    <span class="n">lr</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">lr</span> <span class="o">*</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">**</span> <span class="p">(</span><span class="n">step</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">param_group</span> <span class="ow">in</span> <span class="n">optimizer</span><span class="p">.</span><span class="n">param_groups</span><span class="p">:</span>
        <span class="n">param_group</span><span class="p">[</span><span class="sh">'</span><span class="s">lr</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">lr</span>
</pre></table></code></div></div></details><h4 id="p313-config">P3.1.3 config</h4><p>配置信息位于data/config.py</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1"># for making bounding boxes pretty
</span><span class="n">COLORS</span> <span class="o">=</span> <span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
          <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>

<span class="n">MEANS</span> <span class="o">=</span> <span class="p">(</span><span class="mi">104</span><span class="p">,</span> <span class="mi">117</span><span class="p">,</span> <span class="mi">123</span><span class="p">)</span>

<span class="c1"># SSD300 CONFIGS
</span><span class="n">voc</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">'</span><span class="s">num_classes</span><span class="sh">'</span><span class="p">:</span> <span class="mi">21</span><span class="p">,</span>                      <span class="c1"># 类别数
</span>    <span class="sh">'</span><span class="s">lr_steps</span><span class="sh">'</span><span class="p">:</span> <span class="p">(</span><span class="mi">80000</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="mi">120000</span><span class="p">),</span>    <span class="c1"># 每次调整lr的step
</span>    <span class="sh">'</span><span class="s">max_iter</span><span class="sh">'</span><span class="p">:</span> <span class="mi">120000</span><span class="p">,</span>                     <span class="c1"># 最大训练次数
</span>    <span class="sh">'</span><span class="s">feature_maps</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">38</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># 不同分辨率特征宽度（宽高相等）
</span>    <span class="sh">'</span><span class="s">min_dim</span><span class="sh">'</span><span class="p">:</span> <span class="mi">300</span><span class="p">,</span>                         <span class="c1"># 输入网络的图像宽高
</span>    <span class="sh">'</span><span class="s">steps</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span>          <span class="c1"># 多分辨率的特征图相比于输入图像缩小的倍数
</span>    <span class="sh">'</span><span class="s">min_sizes</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">162</span><span class="p">,</span> <span class="mi">213</span><span class="p">,</span> <span class="mi">264</span><span class="p">],</span>   <span class="c1"># 不同分辨率检测的目标的最小值
</span>    <span class="sh">'</span><span class="s">max_sizes</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">111</span><span class="p">,</span> <span class="mi">162</span><span class="p">,</span> <span class="mi">213</span><span class="p">,</span> <span class="mi">264</span><span class="p">,</span> <span class="mi">315</span><span class="p">],</span>  <span class="c1"># 用于计算宽高比为1时，额外的特定scale的宽高的临时变量
</span>    <span class="sh">'</span><span class="s">aspect_ratios</span><span class="sh">'</span><span class="p">:</span> <span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]],</span>   <span class="c1"># 额外的长宽比，此处每个对应两个，加上长宽比为1的及长宽比为1时额外的，共[4, 6, 6, 6, 4, 4]，和ssd.py中mbox['300']一致
</span>    <span class="sh">'</span><span class="s">variance</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
    <span class="sh">'</span><span class="s">clip</span><span class="sh">'</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
    <span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">VOC</span><span class="sh">'</span><span class="p">,</span>
<span class="p">}</span>
</pre></table></code></div></div></details><h3 id="p32-测试代码">P3.2 测试代码</h3><p>测试代码位于test.py，其main中调用test_voc，其进一步调用test_net。</p><h4 id="p321-test_voc">P3.2.1 test_voc</h4><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">test_voc</span><span class="p">():</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">VOC_CLASSES</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># +1 background     voc数据库上类别数量（voc类别+背景）
</span>    <span class="n">net</span> <span class="o">=</span> <span class="nf">build_ssd</span><span class="p">(</span><span class="sh">'</span><span class="s">test</span><span class="sh">'</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span> <span class="c1"># initialize SSD    # 得到测试时的ssd检测网络
</span>    <span class="n">net</span><span class="p">.</span><span class="nf">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">trained_model</span><span class="p">))</span>    <span class="c1"># 载入训练的模型  # load net
</span>    <span class="n">net</span><span class="p">.</span><span class="nf">eval</span><span class="p">()</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Finished loading model!</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">testset</span> <span class="o">=</span> <span class="nc">VOCDetection</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">voc_root</span><span class="p">,</span> <span class="p">[(</span><span class="sh">'</span><span class="s">2007</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">test</span><span class="sh">'</span><span class="p">)],</span> <span class="bp">None</span><span class="p">,</span> <span class="nc">VOCAnnotationTransform</span><span class="p">())</span>     <span class="c1"># 得到voc的信息，供DataLoader使用，此处不对数据做argument  # load data
</span>    <span class="k">if</span> <span class="n">args</span><span class="p">.</span><span class="n">cuda</span><span class="p">:</span>
        <span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">.</span><span class="nf">cuda</span><span class="p">()</span>
        <span class="n">cudnn</span><span class="p">.</span><span class="n">benchmark</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="nf">test_net</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">save_folder</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">cuda</span><span class="p">,</span> <span class="n">testset</span><span class="p">,</span> <span class="nc">BaseTransform</span><span class="p">(</span><span class="n">net</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="mi">104</span><span class="p">,</span> <span class="mi">117</span><span class="p">,</span> <span class="mi">123</span><span class="p">)),</span> <span class="n">thresh</span><span class="o">=</span><span class="n">args</span><span class="p">.</span><span class="n">visual_threshold</span><span class="p">)</span>    <span class="c1"># BaseTransform：图像转float，并减均值  # evaluation
</span></pre></table></code></div></div></details><h4 id="p322-test_net">P3.2.2 test_net</h4><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">test_net</span><span class="p">(</span><span class="n">save_folder</span><span class="p">,</span> <span class="n">net</span><span class="p">,</span> <span class="n">cuda</span><span class="p">,</span> <span class="n">testset</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">thresh</span><span class="p">):</span>
    <span class="c1"># dump predictions and assoc. ground truth to text file for now
</span>    <span class="c1"># 测试阶段对检测结果进行nms，去除太近的框。
</span>    <span class="n">filename</span> <span class="o">=</span> <span class="n">save_folder</span><span class="o">+</span><span class="sh">'</span><span class="s">test1.txt</span><span class="sh">'</span>
    <span class="n">num_images</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">testset</span><span class="p">)</span>    <span class="c1"># 测试集图像数量
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_images</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Testing image {:d}/{:d}....</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_images</span><span class="p">))</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">testset</span><span class="p">.</span><span class="nf">pull_image</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>     <span class="c1"># 得到当前图像    HWC
</span>        <span class="n">img_id</span><span class="p">,</span> <span class="n">annotation</span> <span class="o">=</span> <span class="n">testset</span><span class="p">.</span><span class="nf">pull_anno</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>   <span class="c1"># 得到当前图像相关信息
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="nf">transform</span><span class="p">(</span><span class="n">img</span><span class="p">)[</span><span class="mi">0</span><span class="p">]).</span><span class="nf">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># 输入网络的数据，将HWC转CHW
</span>        <span class="n">x</span> <span class="o">=</span> <span class="nc">Variable</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>   <span class="c1"># CHW转BCHW，其中B=1
</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sh">'</span><span class="se">\n</span><span class="s">GROUND TRUTH FOR: </span><span class="sh">'</span><span class="o">+</span><span class="n">img_id</span><span class="o">+</span><span class="sh">'</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="n">annotation</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sh">'</span><span class="s">label: </span><span class="sh">'</span><span class="o">+</span><span class="sh">'</span><span class="s"> || </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">box</span><span class="p">)</span><span class="o">+</span><span class="sh">'</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span>    <span class="c1"># gt信息
</span>        <span class="k">if</span> <span class="n">cuda</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">cuda</span><span class="p">()</span>

        <span class="n">y</span> <span class="o">=</span> <span class="nf">net</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>      <span class="c1"># forward pass  得到检测的目标的信息
</span>        <span class="n">detections</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">data</span>    <span class="c1"># [bs, num_classes, top_k, 5]   返回的检测结果
</span>        <span class="c1"># scale each detection back up to the image   将检测的目标缩放到原始图像上
</span>        <span class="n">scale</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">([</span><span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">img</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>   <span class="c1"># 将归一化的预测rect转换到绝对坐标的参数（图像依旧为HWC）
</span>        <span class="n">pred_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">detections</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>    <span class="c1"># 依次遍历每个类别
</span>            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># 当前类别分类概率最大的目标的索引
</span>            <span class="k">while</span> <span class="n">detections</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.6</span><span class="p">:</span>    <span class="c1"># 当前目标分类概率大于0.6时
</span>                <span class="k">if</span> <span class="n">pred_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sh">'</span><span class="s">PREDICTIONS: </span><span class="sh">'</span><span class="o">+</span><span class="sh">'</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">detections</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>    <span class="c1"># 当前类别分类概率最大的目标的分类概率
</span>                <span class="n">label_name</span> <span class="o">=</span> <span class="n">labelmap</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>        <span class="c1"># 得到实际的类别。由于实际类别不包括背景，因而需要i-1
</span>                <span class="n">pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">detections</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">*</span><span class="n">scale</span><span class="p">).</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>    <span class="c1"># 得到实际rect（分别乘以宽、高、宽、高）
</span>                <span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>   <span class="c1"># 实际坐标
</span>                <span class="n">pred_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">pred_num</span><span class="p">)</span><span class="o">+</span><span class="sh">'</span><span class="s"> label: </span><span class="sh">'</span><span class="o">+</span><span class="n">label_name</span><span class="o">+</span><span class="sh">'</span><span class="s"> score: </span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="n">score</span><span class="p">)</span> <span class="o">+</span> <span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="o">+</span><span class="sh">'</span><span class="s"> || </span><span class="sh">'</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">)</span> <span class="o">+</span> <span class="sh">'</span><span class="se">\n</span><span class="sh">'</span><span class="p">)</span>   <span class="c1"># 保存结果
</span>                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>    <span class="c1"># 更新当前目标索引
</span></pre></table></code></div></div></details><h4 id="p323-basetransform">P3.2.3 BaseTransform</h4><p>用于将图像转float，并减均值。位于data/<strong>init</strong>.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">base_transform</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">mean</span><span class="p">):</span>   <span class="c1"># 图像转float，并减均值   HWC
</span>    <span class="n">x</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">)).</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">mean</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">class</span> <span class="nc">BaseTransform</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">mean</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">base_transform</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">mean</span><span class="p">),</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>    <span class="c1"># 图像转float，并减均值   HWC
</span></pre></table></code></div></div></details><h3 id="p33-ssd网络build_ssd">P3.3 SSD网络build_ssd</h3><p>train和test均会调用build_ssd，其位于ssd.py。通过multibox对不同分辨率的特征预测目标框及目标类别，multibox使用vgg得到骨干网络、使用add_extras增加新的conv网络，最终返回SSD网络。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">build_ssd</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">21</span><span class="p">):</span>   <span class="c1"># 创建ssd检测网络
</span>    <span class="k">if</span> <span class="n">phase</span> <span class="o">!=</span> <span class="sh">"</span><span class="s">test</span><span class="sh">"</span> <span class="ow">and</span> <span class="n">phase</span> <span class="o">!=</span> <span class="sh">"</span><span class="s">train</span><span class="sh">"</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">ERROR: Phase: </span><span class="sh">"</span> <span class="o">+</span> <span class="n">phase</span> <span class="o">+</span> <span class="sh">"</span><span class="s"> not recognized</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">!=</span> <span class="mi">300</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">ERROR: You specified size </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">repr</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="sh">"</span><span class="s">. However, currently only SSD300 (size=300) is supported!</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="c1"># multibox为多分辨率的ssd网络
</span>    <span class="n">base_</span><span class="p">,</span> <span class="n">extras_</span><span class="p">,</span> <span class="n">head_</span> <span class="o">=</span> <span class="nf">multibox</span><span class="p">(</span><span class="nf">vgg</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="nf">str</span><span class="p">(</span><span class="n">size</span><span class="p">)],</span> <span class="mi">3</span><span class="p">),</span>                <span class="c1"># 骨干网络
</span>                                     <span class="nf">add_extras</span><span class="p">(</span><span class="n">extras</span><span class="p">[</span><span class="nf">str</span><span class="p">(</span><span class="n">size</span><span class="p">)],</span> <span class="mi">1024</span><span class="p">),</span>    <span class="c1"># 新增加的conv网络
</span>                                     <span class="n">mbox</span><span class="p">[</span><span class="nf">str</span><span class="p">(</span><span class="n">size</span><span class="p">)],</span> <span class="n">num_classes</span><span class="p">)</span>
    <span class="k">return</span> <span class="nc">SSD</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">base_</span><span class="p">,</span> <span class="n">extras_</span><span class="p">,</span> <span class="n">head_</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>   <span class="c1"># 返回ssd网络
</span></pre></table></code></div></div></details><h4 id="p331-multibox">P3.3.1 multibox</h4><p>位于ssd.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">multibox</span><span class="p">(</span><span class="n">vgg</span><span class="p">,</span> <span class="n">extra_layers</span><span class="p">,</span> <span class="n">cfg</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">):</span>   <span class="c1"># 对不同分辨率的特征预测目标框及目标类别（使用conv2d替代fc）
</span>    <span class="c1"># cfg = [4, 6, 6, 6, 4, 4]   不同分辨率特征图上每个位置的default box数量
</span>    <span class="c1"># num_classes = 21
</span>    <span class="n">loc_layers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">conf_layers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vgg_source</span> <span class="o">=</span> <span class="p">[</span><span class="mi">21</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>   <span class="c1"># vgg骨干网络需要得到多分辨率特征的层数
</span>    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">vgg_source</span><span class="p">):</span>
        <span class="n">loc_layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">vgg</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">cfg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>    <span class="c1"># 多分辨率，将cov当做fc，拟合目标框坐标
</span>        <span class="n">conf_layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">vgg</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">cfg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="c1"># 多分辨率，将cov当做fc，分类目标类别
</span>    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">extra_layers</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">loc_layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">cfg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>     <span class="c1"># 多分辨率，将cov当做fc，拟合目标框坐标
</span>        <span class="n">conf_layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">cfg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>   <span class="c1"># 多分辨率，将cov当做fc，分类目标类别
</span>    <span class="k">return</span> <span class="n">vgg</span><span class="p">,</span> <span class="n">extra_layers</span><span class="p">,</span> <span class="p">(</span><span class="n">loc_layers</span><span class="p">,</span> <span class="n">conf_layers</span><span class="p">)</span>   <span class="c1"># 返回相应结果
</span>
<span class="n">base</span> <span class="o">=</span> <span class="p">{</span>    <span class="c1"># 只支持ssd300，所以512部分为空
</span>    <span class="sh">'</span><span class="s">300</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="sh">'</span><span class="s">M</span><span class="sh">'</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="sh">'</span><span class="s">M</span><span class="sh">'</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="sh">'</span><span class="s">M</span><span class="sh">'</span><span class="p">,</span>
            <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">],</span>
    <span class="sh">'</span><span class="s">512</span><span class="sh">'</span><span class="p">:</span> <span class="p">[],</span>
<span class="p">}</span>
<span class="n">extras</span> <span class="o">=</span> <span class="p">{</span>   <span class="c1"># 只支持ssd300，所以512部分为空
</span>    <span class="sh">'</span><span class="s">300</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">256</span><span class="p">,</span> <span class="sh">'</span><span class="s">S</span><span class="sh">'</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="sh">'</span><span class="s">S</span><span class="sh">'</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">],</span>
    <span class="sh">'</span><span class="s">512</span><span class="sh">'</span><span class="p">:</span> <span class="p">[],</span>
<span class="p">}</span>
<span class="n">mbox</span> <span class="o">=</span> <span class="p">{</span>   <span class="c1"># 只支持ssd300，所以512部分为空
</span>    <span class="sh">'</span><span class="s">300</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>  <span class="c1"># number of boxes per feature map location   不同分辨率特征图上每个位置的default box数量，和PriorBox.py中forward的结果一致
</span>    <span class="sh">'</span><span class="s">512</span><span class="sh">'</span><span class="p">:</span> <span class="p">[],</span>
<span class="p">}</span>
</pre></table></code></div></div></details><h4 id="p332-vgg">P3.3.2 vgg</h4><p>位于ssd.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1"># This function is derived from torchvision VGG make_layers()
# https://github.com/pytorch/vision/blob/master/torchvision/models/vgg.py
</span><span class="k">def</span> <span class="nf">vgg</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">batch_norm</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>  
    <span class="c1"># cfg = [64, 64, 'M', 128, 128, 'M', 256, 256, 256, 'C', 512, 512, 512, 'M', 512, 512, 512]   # conv_1到conv_5
</span>    <span class="c1"># i = 3  为输入通道数
</span>    <span class="n">layers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">in_channels</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cfg</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="sh">'</span><span class="s">M</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nn</span><span class="p">.</span><span class="nc">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)]</span>    <span class="c1"># ceil_mode=False时，maxpool计算输出图像尺寸时向内取整
</span>        <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nn</span><span class="p">.</span><span class="nc">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ceil_mode</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>   <span class="c1"># ceil_mode=True时，maxpool计算输出图像尺寸时向外取整
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">conv2d</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># conv层
</span>            <span class="k">if</span> <span class="n">batch_norm</span><span class="p">:</span>
                <span class="n">layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">conv2d</span><span class="p">,</span> <span class="n">nn</span><span class="p">.</span><span class="nc">BatchNorm2d</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>   <span class="c1"># conv+bn+ReLU
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="n">layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">conv2d</span><span class="p">,</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>       <span class="c1"># conv+ReLU
</span>            <span class="n">in_channels</span> <span class="o">=</span> <span class="n">v</span>
    <span class="n">pool5</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">conv6</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>   <span class="c1"># 空洞卷积，增大感受野
</span>    <span class="n">conv7</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">pool5</span><span class="p">,</span> <span class="n">conv6</span><span class="p">,</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">conv7</span><span class="p">,</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">layers</span>
</pre></table></code></div></div></details><h4 id="p333-add_extras">P3.3.3 add_extras</h4><p>位于ssd.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">add_extras</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">batch_norm</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>  <span class="c1"># 用于对vgg19的特征进行缩放，方便得到多分辨率特征
</span>    <span class="c1"># Extra layers added to VGG for feature scaling
</span>    <span class="c1"># cfg = [256, 'S', 512, 128, 'S', 256, 128, 256, 128, 256]
</span>    <span class="c1"># i = 1024  vgg的conv7+ReLU的输出通道数
</span>
    <span class="c1"># Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1))
</span>    <span class="c1"># Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))
</span>    <span class="c1"># Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1))
</span>    <span class="c1"># Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))
</span>    <span class="c1"># Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1))
</span>    <span class="c1"># Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1))
</span>    <span class="c1"># Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1))
</span>    <span class="c1"># Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1))
</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">in_channels</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">cfg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">in_channels</span> <span class="o">!=</span> <span class="sh">'</span><span class="s">S</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="sh">'</span><span class="s">S</span><span class="sh">'</span><span class="p">:</span>
                <span class="n">layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">cfg</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)[</span><span class="n">flag</span><span class="p">],</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>   <span class="c1"># 3*3conv
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="n">layers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nn</span><span class="p">.</span><span class="nc">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)[</span><span class="n">flag</span><span class="p">])]</span>    <span class="c1"># 1*1conv
</span>            <span class="n">flag</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">flag</span>
        <span class="n">in_channels</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">layers</span>
</pre></table></code></div></div></details><h4 id="p334-ssd">P3.3.4 SSD</h4><p>位于ssd.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">SSD</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Single Shot Multibox Architecture
    The network is composed of a base VGG network followed by the
    added multibox conv layers.  Each multibox layer branches into
        1) conv2d for class conf scores
        2) conv2d for localization predictions
        3) associated priorbox layer to produce default bounding
           boxes specific to the layer</span><span class="sh">'</span><span class="s">s feature map size.
    See: https://arxiv.org/pdf/1512.02325.pdf for more details.

    Args:
        phase: (string) Can be </span><span class="sh">"</span><span class="s">test</span><span class="sh">"</span><span class="s"> or </span><span class="sh">"</span><span class="s">train</span><span class="sh">"</span><span class="s">
        size: input image size
        base: VGG16 layers for input, size of either 300 or 500
        extras: extra layers that feed to multibox loc and conf layers
        head: </span><span class="sh">"</span><span class="s">multibox head</span><span class="sh">"</span><span class="s"> consists of loc and conf conv layers
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">extras</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">SSD</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span>    <span class="c1"># 训练还是测试阶段
</span>        <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">num_classes</span>   <span class="c1"># 分类的类别
</span>        <span class="n">self</span><span class="p">.</span><span class="n">cfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">coco</span><span class="p">,</span> <span class="n">voc</span><span class="p">)[</span><span class="n">num_classes</span> <span class="o">==</span> <span class="mi">21</span><span class="p">]</span>   <span class="c1"># 配置信息
</span>        <span class="n">self</span><span class="p">.</span><span class="n">priorbox</span> <span class="o">=</span> <span class="nc">PriorBox</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">cfg</span><span class="p">)</span>   <span class="c1"># 不同分辨率的密集先验坐标
</span>        <span class="n">self</span><span class="p">.</span><span class="n">priors</span> <span class="o">=</span> <span class="nc">Variable</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">priorbox</span><span class="p">.</span><span class="nf">forward</span><span class="p">(),</span> <span class="n">volatile</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># 得到不同分辨率的密集先验坐标：N*4  N个[cx, cy, w, h]
</span>        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>

        <span class="c1"># SSD network
</span>        <span class="n">self</span><span class="p">.</span><span class="n">vgg</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ModuleList</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>    <span class="c1"># vgg骨干网络
</span>        <span class="c1"># Layer learns to scale the l2 normalized features from conv4_3
</span>        <span class="n">self</span><span class="p">.</span><span class="n">L2Norm</span> <span class="o">=</span> <span class="nc">L2Norm</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>    <span class="c1">#   对输入特征进行l2归一化，并乘以可学习的参数，进行变换
</span>        <span class="n">self</span><span class="p">.</span><span class="n">extras</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ModuleList</span><span class="p">(</span><span class="n">extras</span><span class="p">)</span>   <span class="c1"># 额外信息
</span>
        <span class="n">self</span><span class="p">.</span><span class="n">loc</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ModuleList</span><span class="p">(</span><span class="n">head</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>    <span class="c1"># 定位网络
</span>        <span class="n">self</span><span class="p">.</span><span class="n">conf</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ModuleList</span><span class="p">(</span><span class="n">head</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>   <span class="c1"># 分类网络
</span>
        <span class="k">if</span> <span class="n">phase</span> <span class="o">==</span> <span class="sh">'</span><span class="s">test</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">softmax</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Softmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># 测试阶段，使用softmax
</span>            <span class="n">self</span><span class="p">.</span><span class="n">detect</span> <span class="o">=</span> <span class="nc">Detect</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.45</span><span class="p">)</span>   <span class="c1"># 测试阶段的Detect
</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">Applies network layers and ops on input image(s) x.
        Args:
            x: input image or batch of images. Shape: [batch,3,300,300].
        Return:
            Depending on phase:
            test:
                Variable(tensor) of output class label predictions, confidence score, and corresponding location predictions for
                each object detected. Shape: [batch,topk,7]
            train:
                list of concat outputs from:
                    1: confidence layers, Shape: [batch*num_priors,num_classes]
                    2: localization layers, Shape: [batch,num_priors*4]
                    3: priorbox layers, Shape: [2,num_priors*4]
        </span><span class="sh">"""</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="nf">list</span><span class="p">()</span>  <span class="c1"># 缓存6个分辨率的特征
</span>        <span class="n">loc</span> <span class="o">=</span> <span class="nf">list</span><span class="p">()</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="nf">list</span><span class="p">()</span>

        <span class="c1"># apply vgg up to conv4_3 relu
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">23</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">vgg</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># 使用vgg到conv4_3的relu层
</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nc">L2Norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># 对vgg之后的特征进行l2归一化，并乘以可学习的参数，进行变换，得到第一个多分辨率特征，用于拟合目标框及目标类别
</span>        <span class="n">sources</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># apply vgg up to fc7
</span>        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">vgg</span><span class="p">)):</span>   <span class="c1"># 使用vgg从conv4_3的relu之后到fc7层
</span>            <span class="n">x</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">vgg</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">x</span><span class="p">)</span>
        <span class="n">sources</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># 得到fc7之后的特征（实际使用conv2d替代fc），得到第二个多分辨率特征
</span>
        <span class="c1"># apply extra layers and cache source layer outputs
</span>        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">extras</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">relu</span><span class="p">(</span><span class="nf">v</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sources</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># 特征通过额外层，缓存多分辨率特征，得到3、4、5、6个多分辨率特征
</span>
        <span class="c1"># apply multibox head to source layers
</span>        <span class="nf">for </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">loc</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">conf</span><span class="p">):</span>   <span class="c1"># 不同分辨率特征，不同分辨率定位网络层，不同分辨率分类网络层
</span>            <span class="n">loc</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">l</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="nf">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">contiguous</span><span class="p">())</span>   <span class="c1"># 得到不同分辨率特征的定位特征，供之后cat及reshape成B*N*4的拟合定位特征
</span>            <span class="n">conf</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">c</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="nf">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">contiguous</span><span class="p">())</span>  <span class="c1"># 得到不同分辨率特征的分类特征，供之后cat及reshape成B*N*self.num_classes的拟合分类特征
</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">o</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">loc</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">#不同分辨率的定位特征拼接（保留bs，其他维度合并，最终为bs*特征reshape之和）
</span>        <span class="n">conf</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">o</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">conf</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">#不同分辨率的分类特征拼接（保留bs，其他维度合并，最终为bs*特征reshape之和）
</span>        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">phase</span> <span class="o">==</span> <span class="sh">"</span><span class="s">test</span><span class="sh">"</span><span class="p">:</span>     <span class="c1"># 测试阶段，则直接对检测结果分类，得到输出
</span>            <span class="n">output</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">detect</span><span class="p">(</span>                                              <span class="c1"># 输入相关结果，进行检测。
</span>                <span class="n">loc</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">loc</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>                                  <span class="c1"># loc preds     预测的多个目标的坐标
</span>                <span class="n">self</span><span class="p">.</span><span class="nf">softmax</span><span class="p">(</span><span class="n">conf</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">conf</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span><span class="p">)),</span>   <span class="c1"># conf preds    预测的每个目标对应的类别
</span>                <span class="n">self</span><span class="p">.</span><span class="n">priors</span><span class="p">.</span><span class="nf">type</span><span class="p">(</span><span class="nf">type</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">))</span>                                 <span class="c1"># default boxes 不同分辨率的密集先验坐标：N个[cx, cy, w, h]
</span>            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>      <span class="c1"># 训练阶段，则返回定位信息及分类信息，得到输出，供计算损失使用
</span>            <span class="n">output</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">loc</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">loc</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>   <span class="c1"># reshape成bs*N*4维度的向量，代表密集预测的多个坐标（此处为预测的偏移）
</span>                <span class="n">conf</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">conf</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span><span class="p">),</span>  <span class="c1"># reshape成bs*N*num_classes维度的向量，代表密集预测的分类结果
</span>                <span class="n">self</span><span class="p">.</span><span class="n">priors</span>                     <span class="c1"># 不同分辨率的密集先验坐标：N*4   N个[cx, cy, w, h]   由于图像输入大小固定，因而先验坐标共用1个即可
</span>            <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>   <span class="c1"># 返回输出
</span>
    <span class="k">def</span> <span class="nf">load_weights</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">base_file</span><span class="p">):</span>      <span class="c1"># load之前训练的权重
</span>        <span class="n">other</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">splitext</span><span class="p">(</span><span class="n">base_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="sh">'</span><span class="s">.pkl</span><span class="sh">'</span> <span class="ow">or</span> <span class="sh">'</span><span class="s">.pth</span><span class="sh">'</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Loading weights into state dict...</span><span class="sh">'</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">base_file</span><span class="p">,</span>
                                 <span class="n">map_location</span><span class="o">=</span><span class="k">lambda</span> <span class="n">storage</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">storage</span><span class="p">))</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Finished!</span><span class="sh">'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Sorry only .pth and .pkl files supported.</span><span class="sh">'</span><span class="p">)</span>
</pre></table></code></div></div></details><h4 id="p335密集先验坐标priorbox">P3.3.5密集先验坐标PriorBox</h4><p>SSD中PriorBox用于得到不同分辨率的密集先验坐标，其位于layers/functions/prior_box.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">PriorBox</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 得到不同分辨率的密集先验坐标：N个[cx, cy, w, h]
</span>    <span class="sh">"""</span><span class="s">Compute priorbox coordinates in center-offset form for each source feature map.</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">PriorBox</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">image_size</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">min_dim</span><span class="sh">'</span><span class="p">]</span>    <span class="c1"># 图像宽高，目前都是300
</span>        <span class="c1"># number of priors for feature map location (either 4 or 6)
</span>        <span class="n">self</span><span class="p">.</span><span class="n">num_priors</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">aspect_ratios</span><span class="sh">'</span><span class="p">])</span>   <span class="c1"># 长宽比的长度
</span>        <span class="n">self</span><span class="p">.</span><span class="n">variance</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">variance</span><span class="sh">'</span><span class="p">]</span> <span class="ow">or</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">feature_maps</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">feature_maps</span><span class="sh">'</span><span class="p">]</span>  <span class="c1"># 不同分辨率特征宽度（宽高相等）  [38, 19, 10, 5, 3, 1]
</span>        <span class="n">self</span><span class="p">.</span><span class="n">min_sizes</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">min_sizes</span><span class="sh">'</span><span class="p">]</span>        <span class="c1"># 不同分辨率检测的目标的最小值  [30, 60, 111, 162, 213, 264]
</span>        <span class="n">self</span><span class="p">.</span><span class="n">max_sizes</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">max_sizes</span><span class="sh">'</span><span class="p">]</span>        <span class="c1"># 用于计算宽高比为1时，额外的特定scale的宽高的临时变量  [60, 111, 162, 213, 264, 315]
</span>        <span class="n">self</span><span class="p">.</span><span class="n">steps</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">steps</span><span class="sh">'</span><span class="p">]</span>                <span class="c1"># 多分辨率的特征图相比于输入图像缩小的倍数。[8, 16, 32, 64, 100, 300]
</span>        <span class="n">self</span><span class="p">.</span><span class="n">aspect_ratios</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">aspect_ratios</span><span class="sh">'</span><span class="p">]</span>   <span class="c1"># 长宽比  [[2], [2, 3], [2, 3], [2, 3], [2], [2]]
</span>        <span class="n">self</span><span class="p">.</span><span class="n">clip</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">clip</span><span class="sh">'</span><span class="p">]</span>   <span class="c1"># True
</span>        <span class="n">self</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]</span>   <span class="c1"># VOC或者COCO
</span>        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">variance</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">Variances must be greater than 0</span><span class="sh">'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">feature_maps</span><span class="p">):</span>      <span class="c1"># 不同分辨率特征宽度（宽高相等） [38, 19, 10, 5, 3, 1]
</span>            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">product</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>   <span class="c1"># product(range(f), repeat=2)等价于product(range(f), range(f))
</span>                <span class="n">f_k</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">image_size</span> <span class="o">/</span> <span class="n">self</span><span class="p">.</span><span class="n">steps</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>  <span class="c1"># 当前分辨率特征图相比于输入图像缩小倍数。 image_size = 300, steps = [8, 16, 32, 64, 100, 300]
</span>                <span class="c1"># unit center x,y
</span>                <span class="n">cx</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">f_k</span>   <span class="c1"># 每个rect归一化的中心x坐标
</span>                <span class="n">cy</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">f_k</span>   <span class="c1"># 每个rect归一化的中心y坐标
</span>
                <span class="c1"># aspect_ratio: 1
</span>                <span class="c1"># rel size: min_size
</span>                <span class="n">s_k</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">min_sizes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">self</span><span class="p">.</span><span class="n">image_size</span>   <span class="c1"># 不同分辨率检测目标的归一化最小值
</span>                <span class="n">mean</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">s_k</span><span class="p">,</span> <span class="n">s_k</span><span class="p">]</span>

                <span class="c1"># aspect_ratio: 1
</span>                <span class="c1"># rel size: sqrt(s_k * s_(k+1))
</span>                <span class="n">s_k_prime</span> <span class="o">=</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">s_k</span> <span class="o">*</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">max_sizes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">self</span><span class="p">.</span><span class="n">image_size</span><span class="p">))</span>  <span class="c1"># 论文中宽高比为1时，额外的特定scale的宽高
</span>                <span class="n">mean</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">s_k_prime</span><span class="p">,</span> <span class="n">s_k_prime</span><span class="p">]</span>   <span class="c1"># 不同分辨率宽高比为1时，额外的特定scale的宽高
</span>
                <span class="c1"># rest of aspect ratios  由于每个ar对应宽的和高的两个mean，因而此处分别增加len(ar)*2，即[2,4,4,4,2,2]个prior box，
</span>                <span class="c1"># 加上上面的2个prior box，总共[4, 6, 6, 6, 4, 4]个prior box。和ssd.py中mbox['300']一致
</span>                <span class="k">for</span> <span class="n">ar</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">aspect_ratios</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>    <span class="c1">#  [[2], [2, 3], [2, 3], [2, 3], [2], [2]]
</span>                    <span class="n">mean</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">s_k</span><span class="o">*</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">ar</span><span class="p">),</span> <span class="n">s_k</span><span class="o">/</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">ar</span><span class="p">)]</span>   <span class="c1"># 不同分辨率检测的横向目标
</span>                    <span class="n">mean</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">s_k</span><span class="o">/</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">ar</span><span class="p">),</span> <span class="n">s_k</span><span class="o">*</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">ar</span><span class="p">)]</span>   <span class="c1"># 不同分辨率检测的纵向目标
</span>        <span class="c1"># back to torch land
</span>        <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">mean</span><span class="p">).</span><span class="nf">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">clip</span><span class="p">:</span>
            <span class="n">output</span><span class="p">.</span><span class="nf">clamp_</span><span class="p">(</span><span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>   <span class="c1"># 不同分辨率的密集先验坐标：N*4  N个[cx, cy, w, h]
</span></pre></table></code></div></div></details><h4 id="336-对输入特征归一化l2norm">3.3.6 对输入特征归一化L2Norm</h4><p>SSD中L2Norm用于对输入特征进行L2归一化，并乘以可学习的参数，进行变换。其位于layers/modules/l2norm.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">L2Norm</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>   <span class="c1"># 对输入特征进行l2归一化，并乘以可学习的参数，进行变换
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">L2Norm</span><span class="p">,</span><span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">n_channels</span> <span class="o">=</span> <span class="n">n_channels</span>
        <span class="n">self</span><span class="p">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">scale</span> <span class="ow">or</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="n">self</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">n_channels</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">reset_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">init</span><span class="p">.</span><span class="nf">constant_</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">weight</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">gamma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="nf">sqrt</span><span class="p">()</span><span class="o">+</span><span class="n">self</span><span class="p">.</span><span class="n">eps</span>
        <span class="c1">#x /= norm
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">weight</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">3</span><span class="p">).</span><span class="nf">expand_as</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">out</span>
</pre></table></code></div></div></details><h4 id="337-测试阶段的检测detect">3.3.7 测试阶段的检测Detect</h4><p>SSD中Detect用于测试阶段的检测，其位于layers/functions/detection.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Detect</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">At test time, Detect is the final layer of SSD.  Decode location preds, apply non-maximum suppression to location predictions based on conf
    scores and threshold to a top_k number of output predictions for both confidence score and locations.
    </span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">bkg_label</span><span class="p">,</span> <span class="n">top_k</span><span class="p">,</span> <span class="n">conf_thresh</span><span class="p">,</span> <span class="n">nms_thresh</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">num_classes</span>    <span class="c1"># 类别数
</span>        <span class="n">self</span><span class="p">.</span><span class="n">background_label</span> <span class="o">=</span> <span class="n">bkg_label</span>    <span class="c1"># 背景的label  0  
</span>        <span class="n">self</span><span class="p">.</span><span class="n">top_k</span> <span class="o">=</span> <span class="n">top_k</span>      <span class="c1"># nms时top k数量   200
</span>        <span class="n">self</span><span class="p">.</span><span class="n">nms_thresh</span> <span class="o">=</span> <span class="n">nms_thresh</span>    <span class="c1"># nms阈值  0.01    # Parameters used in nms.
</span>        <span class="k">if</span> <span class="n">nms_thresh</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">'</span><span class="s">nms_threshold must be non negative.</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">conf_thresh</span> <span class="o">=</span> <span class="n">conf_thresh</span>     <span class="c1"># 分类的阈值    0.45
</span>        <span class="n">self</span><span class="p">.</span><span class="n">variance</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">variance</span><span class="sh">'</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">loc_data</span><span class="p">,</span> <span class="n">conf_data</span><span class="p">,</span> <span class="n">prior_data</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Args:
            loc_data: (tensor) Loc preds from loc layers  Shape: [batch,num_priors*4]     预测的不同分辨率的密集位置信息（此处为预测的偏移offset）
            conf_data: (tensor) Shape: Conf preds from conf layers  Shape: [batch*num_priors,num_classes]    预测的不同分辨率的密集分类概率
            prior_data: (tensor) Prior boxes and variances from priorbox layers  Shape: [1,num_priors,4]     不同分辨率的密集先验坐标：N个[cx, cy, w, h]
        </span><span class="sh">"""</span>
        <span class="c1"># 测试阶段对检测结果进行nms，去除太近的框。
</span>        <span class="n">num</span> <span class="o">=</span> <span class="n">loc_data</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># batch size
</span>        <span class="n">num_priors</span> <span class="o">=</span> <span class="n">prior_data</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># 不同分辨率的密集先验坐标数量
</span>        <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">top_k</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>     <span class="c1"># 返回的检测结果
</span>        <span class="n">conf_preds</span> <span class="o">=</span> <span class="n">conf_data</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">num_priors</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span><span class="p">).</span><span class="nf">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>    <span class="c1"># [batch*num_priors,num_classes]-&gt;[batch, num_priors,num_classes]-&gt;[batch, num_classes, num_priors]
</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>   <span class="c1"># 依次处理每张图片     Decode predictions into bboxes.
</span>            <span class="n">decoded_boxes</span> <span class="o">=</span> <span class="nf">decode</span><span class="p">(</span><span class="n">loc_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">prior_data</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">variance</span><span class="p">)</span>    <span class="c1"># 解码偏移信息，得到实际预测的bbox。从[cx, cy, w, h]到[xmin, ymin, xmax, ymax]     # [num_priors, 4] 
</span>            <span class="n">conf_scores</span> <span class="o">=</span> <span class="n">conf_preds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">clone</span><span class="p">()</span>   <span class="c1"># 得到当前图像的分类概率。[num_classes, num_priors]    For each class, perform nms  
</span>
            <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span><span class="p">):</span>    <span class="c1"># 依次对每个类别进行nms（去掉背景：cl=0）   
</span>                <span class="n">c_mask</span> <span class="o">=</span> <span class="n">conf_scores</span><span class="p">[</span><span class="n">cl</span><span class="p">].</span><span class="nf">gt</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">conf_thresh</span><span class="p">)</span>   <span class="c1"># 得到当前图像分到当前类别的概率大于阈值的mask   [num_priors] 
</span>                <span class="n">scores</span> <span class="o">=</span> <span class="n">conf_scores</span><span class="p">[</span><span class="n">cl</span><span class="p">][</span><span class="n">c_mask</span><span class="p">]</span>   <span class="c1"># 得到当前图像分到当前类别的概率大于阈值的那些概率   [k个] 
</span>                <span class="k">if</span> <span class="n">scores</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">l_mask</span> <span class="o">=</span> <span class="n">c_mask</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">expand_as</span><span class="p">(</span><span class="n">decoded_boxes</span><span class="p">)</span>   <span class="c1">#  当前图像分到当前类别的概率大于阈值的那些定位信息的mask   [num_priors, 4] 
</span>                <span class="n">boxes</span> <span class="o">=</span> <span class="n">decoded_boxes</span><span class="p">[</span><span class="n">l_mask</span><span class="p">].</span><span class="nf">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>      <span class="c1">#  当前图像分到当前类别的概率大于阈值的那些定位信息   [k个, 4] 
</span>                <span class="n">ids</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="nf">nms</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">nms_thresh</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">top_k</span><span class="p">)</span>      <span class="c1"># 进行nms，得到保留的索引（实际为top_k个，不过count之后的均为0），及保留的索引的数量  idx of highest scoring and non-overlapping boxes per class
</span>                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="p">:</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">scores</span><span class="p">[</span><span class="n">ids</span><span class="p">[:</span><span class="n">count</span><span class="p">]].</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">boxes</span><span class="p">[</span><span class="n">ids</span><span class="p">[:</span><span class="n">count</span><span class="p">]]),</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1">#  右侧为[count, 5]，将这些结果放到output[i, cl]前count中（output[i, cl]的count之后的均为0）
</span>        <span class="n">flt</span> <span class="o">=</span> <span class="n">output</span><span class="p">.</span><span class="nf">contiguous</span><span class="p">().</span><span class="nf">view</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>   <span class="c1"># [num, self.num_classes * self.top_k, 5]
</span>        <span class="n">_</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">flt</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">].</span><span class="nf">sort</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>   <span class="c1"># 按照框的分类概率由大到小排序，得到索引
</span>        <span class="n">_</span><span class="p">,</span> <span class="n">rank</span> <span class="o">=</span> <span class="n">idx</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># 得到排序后索引的索引，和multibox_loss.py中loss_idx、idx_rank使用方法一样，通过其rank &lt; self.top_k得到原始数据的索引
</span>        <span class="n">flt</span><span class="p">[(</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">top_k</span><span class="p">).</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="nf">expand_as</span><span class="p">(</span><span class="n">flt</span><span class="p">)].</span><span class="nf">fill_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 将前self.top_k个目标置0 ？？？
</span>        <span class="k">return</span> <span class="n">output</span>
</pre></table></code></div></div></details><h4 id="p338-解码偏移信息decode">P3.3.8 解码偏移信息decode</h4><p>位于layers/box_utils.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1"># Adapted from https://github.com/Hakuyume/chainer-ssd
</span><span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>   <span class="c1"># 解码偏移信息，得到实际预测的bbox。从[cx, cy, w, h]到[xmin, ymin, xmax, ymax]
</span>    <span class="sh">"""</span><span class="s">Decode locations from predictions using priors to undo the encoding we did for offset regression at train time.
    Args:
        loc (tensor): location predictions for loc layers, Shape: [num_priors,4]
        priors (tensor): Prior boxes in center-offset form. Shape: [num_priors,4].
        variances: (list[float]) Variances of priorboxes
    Return:
        decoded bounding box predictions
    </span><span class="sh">"""</span>
    <span class="sh">'''</span><span class="s">
    g_x=g</span><span class="sh">'</span><span class="s">_x*d_w*var_0+d_x      y同理，将d_w换成d_h
    g_w=d_w*exp(g</span><span class="sh">'</span><span class="s">_w*var_1)      h同理
    其中，g为gt坐标（此处返回值），g</span><span class="sh">'</span><span class="s">为实际的offset（此处loc），d为先验坐标（此处priors）
    </span><span class="sh">'''</span>
    <span class="n">boxes</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">loc</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">loc</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">*</span> <span class="n">variances</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">boxes</span>
</pre></table></code></div></div></details><h4 id="339-nms">3.3.9 nms</h4><p>位于layers/box_utils.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre><td class="rouge-code"><pre><span class="c1"># Original author: Francisco Massa:
# https://github.com/fmassa/object-detection.torch
# Ported to PyTorch by Max deGroot (02/01/2017)
</span><span class="k">def</span> <span class="nf">nms</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">scores</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">top_k</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Apply non-maximum suppression at test time to avoid detecting too many overlapping bounding boxes for a given object.
    Args:
        boxes: (tensor) The location preds for the img, Shape: [num_priors,4].    [k个, 4] 
        scores: (tensor) The class predscores for the img, Shape:[num_priors].    [k个] 
        overlap: (float) The overlap thresh for suppressing unnecessary boxes.
        top_k: (int) The Maximum number of box preds to consider.
    Return:
        The indices of the kept boxes with respect to num_priors.
    </span><span class="sh">"""</span>

    <span class="n">keep</span> <span class="o">=</span> <span class="n">scores</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">scores</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)).</span><span class="nf">zero_</span><span class="p">().</span><span class="nf">long</span><span class="p">()</span>     <span class="c1"># 需要保留的索引    [k个] 
</span>    <span class="k">if</span> <span class="n">boxes</span><span class="p">.</span><span class="nf">numel</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">keep</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">mul</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>       <span class="c1"># 每个框的面积   torch.mul为对应元素相乘
</span>    <span class="n">v</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">scores</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sort in ascending order    对每个框面积升序排列，得到索引
</span>    
    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="n">top_k</span><span class="p">:]</span>  <span class="c1"># indices of the top-k largest vals   得到框面积最大的后top_k个的索引（索引对应的元素依旧是从小到大的顺序）
</span>    <span class="n">xx1</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">.</span><span class="nf">new</span><span class="p">()</span>   <span class="c1"># 新建一个空的Tensor
</span>    <span class="n">yy1</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">.</span><span class="nf">new</span><span class="p">()</span>
    <span class="n">xx2</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">.</span><span class="nf">new</span><span class="p">()</span>
    <span class="n">yy2</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">.</span><span class="nf">new</span><span class="p">()</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">.</span><span class="nf">new</span><span class="p">()</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">.</span><span class="nf">new</span><span class="p">()</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">idx</span><span class="p">.</span><span class="nf">numel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># idx不为空，一直循环
</span>        <span class="n">i</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># index of current largest val   # 当前最大的rect的索引
</span>        <span class="n">keep</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>   <span class="c1"># 当前最大的rect的索引放到keep中
</span>        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>        <span class="c1"># 元素数量+1
</span>        <span class="k">if</span> <span class="n">idx</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>   <span class="c1"># 只剩1个索引，则退出
</span>            <span class="k">break</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># remove kept element from view   去除最后那个最大的索引，得到其他所有框的索引，用于下面计算和当前框的IoU使用
</span>        <span class="c1"># load bboxes of next highest vals
</span>        <span class="n">torch</span><span class="p">.</span><span class="nf">index_select</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">xx1</span><span class="p">)</span>   <span class="c1"># 按0维（行）索引，将x1中第idx组数据取出来，放到xx1中（此处得到其他所有框的相应rect坐标，用于计算和当前框IoU中的交集）
</span>        <span class="n">torch</span><span class="p">.</span><span class="nf">index_select</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">yy1</span><span class="p">)</span>
        <span class="n">torch</span><span class="p">.</span><span class="nf">index_select</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">xx2</span><span class="p">)</span>
        <span class="n">torch</span><span class="p">.</span><span class="nf">index_select</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">yy2</span><span class="p">)</span>
        <span class="c1"># store element-wise max with next highest score
</span>        <span class="n">xx1</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">clamp</span><span class="p">(</span><span class="n">xx1</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>   <span class="c1"># 截断，确保xx1中所有值都不小于x1[i]，由于需要计算交集，因而确保交集都在当前框内部
</span>        <span class="n">yy1</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">clamp</span><span class="p">(</span><span class="n">yy1</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">y1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">xx2</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">clamp</span><span class="p">(</span><span class="n">xx2</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>   <span class="c1"># 截断，确保xx2中所有值都不大于x2[i]，由于需要计算交集，因而确保交集都在当前框内部
</span>        <span class="n">yy2</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">clamp</span><span class="p">(</span><span class="n">yy2</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">y2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">w</span><span class="p">.</span><span class="nf">resize_as_</span><span class="p">(</span><span class="n">xx2</span><span class="p">)</span>
        <span class="n">h</span><span class="p">.</span><span class="nf">resize_as_</span><span class="p">(</span><span class="n">yy2</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">xx2</span> <span class="o">-</span> <span class="n">xx1</span>    <span class="c1"># 交集的宽度
</span>        <span class="n">h</span> <span class="o">=</span> <span class="n">yy2</span> <span class="o">-</span> <span class="n">yy1</span>    <span class="c1"># 交集的高度
</span>        <span class="c1"># check sizes of xx1 and xx2.. after each iteration
</span>        <span class="n">w</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">clamp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>    <span class="c1"># 确保交集宽高不小于0
</span>        <span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">clamp</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">h</span>    <span class="c1"># 交集
</span>        <span class="c1"># IoU = i / (area(a) + area(b) - i)  # 交并比
</span>        <span class="n">rem_areas</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">index_select</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>  <span class="c1"># load remaining areas     取剩下的rect的面积
</span>        <span class="n">union</span> <span class="o">=</span> <span class="p">(</span><span class="n">rem_areas</span> <span class="o">-</span> <span class="n">inter</span><span class="p">)</span> <span class="o">+</span> <span class="n">area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>     <span class="c1"># 两个rect并集的面积（实际是一组rect和当前rect的并集的面积）
</span>        <span class="n">IoU</span> <span class="o">=</span> <span class="n">inter</span><span class="o">/</span><span class="n">union</span>  <span class="c1"># store result in iou   # 一组rect和当前rect的IoU
</span>        <span class="c1"># keep only elements with an IoU &lt;= overlap
</span>        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">IoU</span><span class="p">.</span><span class="nf">le</span><span class="p">(</span><span class="n">overlap</span><span class="p">)]</span>    <span class="c1">#  抑制和当前框IoU过大的其他框，得到新的索引
</span>    <span class="k">return</span> <span class="n">keep</span><span class="p">,</span> <span class="n">count</span>    <span class="c1"># 得到保留的索引（实际为top_k个，不过count之后的均为0），及保留的索引的数量
</span></pre></table></code></div></div></details><h3 id="p34-vocdetection">P3.4 VOCDetection</h3><p>train和test中会调用VOCDetection，用于得到voc的信息，供DataLoader使用。其位于data/voc0712.py中。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">VOCDetection</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">VOC Detection Dataset Object
    input is image, target is annotation
    Arguments:
        root (string): filepath to VOCdevkit folder.
        image_set (string): imageset to use (eg. </span><span class="sh">'</span><span class="s">train</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">val</span><span class="sh">'</span><span class="s">, </span><span class="sh">'</span><span class="s">test</span><span class="sh">'</span><span class="s">)
        transform (callable, optional): transformation to perform on the input image
        target_transform (callable, optional): transformation to perform on the target `annotation`
            (eg: take in caption string, return tensor of word indices)
        dataset_name (string, optional): which dataset to load. (default: </span><span class="sh">'</span><span class="s">VOC2007</span><span class="sh">'</span><span class="s">)
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
                 <span class="n">image_sets</span><span class="o">=</span><span class="p">[(</span><span class="sh">'</span><span class="s">2012</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">trainval</span><span class="sh">'</span><span class="p">)],</span>   <span class="c1"># ('2007', 'trainval'), 
</span>                 <span class="n">transform</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">target_transform</span><span class="o">=</span><span class="nc">VOCAnnotationTransform</span><span class="p">(),</span>
                 <span class="n">dataset_name</span><span class="o">=</span><span class="sh">'</span><span class="s">VOC0712</span><span class="sh">'</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>              <span class="c1"># 根目录
</span>        <span class="n">self</span><span class="p">.</span><span class="n">image_set</span> <span class="o">=</span> <span class="n">image_sets</span>   <span class="c1"># voc数据库相应序列
</span>        <span class="n">self</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>    <span class="c1"># SSDAugmentation
</span>        <span class="n">self</span><span class="p">.</span><span class="n">target_transform</span> <span class="o">=</span> <span class="n">target_transform</span>   <span class="c1"># 对target_进行变换，从实际标签映射到训练所需的标签：[[xmin, ymin, xmax, ymax, label_ind], ... ]
</span>        <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">dataset_name</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_annopath</span> <span class="o">=</span> <span class="n">osp</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">'</span><span class="s">%s</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Annotations</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">%s.xml</span><span class="sh">'</span><span class="p">)</span>    <span class="c1"># voc子库对应信息的路径，方便下面拼接具体路径
</span>        <span class="n">self</span><span class="p">.</span><span class="n">_imgpath</span> <span class="o">=</span> <span class="n">osp</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">'</span><span class="s">%s</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">JPEGImages</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">%s.jpg</span><span class="sh">'</span><span class="p">)</span>      <span class="c1"># voc对应图片的路径，方便下面拼接具体路径
</span>        <span class="n">self</span><span class="p">.</span><span class="n">ids</span> <span class="o">=</span> <span class="nf">list</span><span class="p">()</span>   <span class="c1"># 每个图像相关信息
</span>        <span class="nf">for </span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="n">image_sets</span><span class="p">:</span>
            <span class="n">rootpath</span> <span class="o">=</span> <span class="n">osp</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">root</span><span class="p">,</span> <span class="sh">'</span><span class="s">VOC</span><span class="sh">'</span> <span class="o">+</span> <span class="n">year</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nf">open</span><span class="p">(</span><span class="n">osp</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">rootpath</span><span class="p">,</span> <span class="sh">'</span><span class="s">ImageSets</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Main</span><span class="sh">'</span><span class="p">,</span> <span class="n">name</span> <span class="o">+</span> <span class="sh">'</span><span class="s">.txt</span><span class="sh">'</span><span class="p">)):</span>
                <span class="n">self</span><span class="p">.</span><span class="n">ids</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">rootpath</span><span class="p">,</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">()))</span>   <span class="c1"># 得到每个图像相关信息
</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>    <span class="c1"># 外部iter在next时会调用
</span>        <span class="n">im</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">pull_item</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>   <span class="c1"># 得到图像，gt信息，高、宽
</span>
        <span class="k">return</span> <span class="n">im</span><span class="p">,</span> <span class="n">gt</span>   <span class="c1"># 返回图像、gt信息
</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">ids</span><span class="p">)</span>   <span class="c1"># 返回当前数据库图像数量
</span>
    <span class="k">def</span> <span class="nf">pull_item</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>    <span class="c1"># 得到图像，gt信息，高、宽
</span>        <span class="n">img_id</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">ids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="n">target</span> <span class="o">=</span> <span class="n">ET</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_annopath</span> <span class="o">%</span> <span class="n">img_id</span><span class="p">).</span><span class="nf">getroot</span><span class="p">()</span>   <span class="c1"># 得到相关信息
</span>        <span class="n">img</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">imread</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_imgpath</span> <span class="o">%</span> <span class="n">img_id</span><span class="p">)</span>     <span class="c1"># 得到图像
</span>        <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">img</span><span class="p">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">target_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">target_transform</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>   <span class="c1"># 对图像相关信息进行相应变换，返回当前图像中目标个数的训练所需的标签：[[xmin, ymin, xmax, ymax, label_ind], ... ]
</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="n">img</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">transform</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">target</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">target</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">])</span>   <span class="c1"># 对图像进行相应变换，有随机裁剪，因而目标数量可能变少（祛除了不满足裁剪条件的目标）
</span>            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>    <span class="c1"># 图像从cv2的bgr变换到rgb
</span>            <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">((</span><span class="n">boxes</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">expand_dims</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>     <span class="c1"># 拼接bbox和labels，同时更新target
</span>        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="n">img</span><span class="p">).</span><span class="nf">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">target</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span>   <span class="c1"># permute(2, 0, 1)将图像从cv2的HWC变换到CHW
</span>
    <span class="k">def</span> <span class="nf">pull_image</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>   <span class="c1"># 读取图像
</span>        <span class="sh">'''</span><span class="s">Returns the original image object at index in PIL form

        Note: not using self.__getitem__(), as any transformations passed in
        could mess up this functionality.

        Argument:
            index (int): index of img to show
        Return:
            PIL img
        </span><span class="sh">'''</span>
        <span class="n">img_id</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">ids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">imread</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_imgpath</span> <span class="o">%</span> <span class="n">img_id</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">IMREAD_COLOR</span><span class="p">)</span>   <span class="c1"># 读取图像  HWC
</span>
    <span class="k">def</span> <span class="nf">pull_anno</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>   <span class="c1"># 得到图像相关信息
</span>        <span class="sh">'''</span><span class="s">Returns the original annotation of image at index

        Note: not using self.__getitem__(), as any transformations passed in
        could mess up this functionality.

        Argument:
            index (int): index of img to get annotation of
        Return:
            list:  [img_id, [(label, bbox coords),...]]
                eg: (</span><span class="sh">'</span><span class="s">001718</span><span class="sh">'</span><span class="s">, [(</span><span class="sh">'</span><span class="s">dog</span><span class="sh">'</span><span class="s">, (96, 13, 438, 332))])
        </span><span class="sh">'''</span>
        <span class="n">img_id</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">ids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">anno</span> <span class="o">=</span> <span class="n">ET</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_annopath</span> <span class="o">%</span> <span class="n">img_id</span><span class="p">).</span><span class="nf">getroot</span><span class="p">()</span>
        <span class="n">gt</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">target_transform</span><span class="p">(</span><span class="n">anno</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img_id</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gt</span>     <span class="c1"># 得到图像相关信息
</span>
    <span class="k">def</span> <span class="nf">pull_tensor</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sh">'''</span><span class="s">Returns the original image at an index in tensor form

        Note: not using self.__getitem__(), as any transformations passed in
        could mess up this functionality.

        Argument:
            index (int): index of img to show
        Return:
            tensorized version of img, squeezed
        </span><span class="sh">'''</span>
        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">pull_image</span><span class="p">(</span><span class="n">index</span><span class="p">)).</span><span class="nf">unsqueeze_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># 得到当前数据库中第index张图像
</span></pre></table></code></div></div></details><h3 id="p35-ssdaugmentation">P3.5 SSDAugmentation</h3><p>VOCDetection参数中包含SSDAugmentation，用于对数据进行扰动。其只在训练阶段使用，测试阶段不使用。位于utils/augmentations.py中。</p><p>扰动主要包括亮度、对比度、色度、饱和度调整，随机交换图像通道，图像随机扩大（粘贴到更大的背景上，边界填充mean），随机裁剪，随机镜像，缩放到固定尺寸（SSD最终输入的尺寸），减均值。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">):</span>
    <span class="n">max_xy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">box_b</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
    <span class="n">min_xy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">box_b</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">clip</span><span class="p">((</span><span class="n">max_xy</span> <span class="o">-</span> <span class="n">min_xy</span><span class="p">),</span> <span class="n">a_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">a_max</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inter</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inter</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">jaccard_numpy</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Compute the jaccard overlap of two sets of boxes.  The jaccard overlap
    is simply the intersection over union of two boxes.
    E.g.:
        A ∩ B / A ∪ B = A ∩ B / (area(A) + area(B) - A ∩ B)
    Args:
        box_a: Multiple bounding boxes, Shape: [num_boxes,4]
        box_b: Single bounding box, Shape: [4]
    Return:
        jaccard overlap: Shape: [box_a.shape[0], box_a.shape[1]]
    </span><span class="sh">"""</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">)</span>
    <span class="n">area_a</span> <span class="o">=</span> <span class="p">((</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
              <span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># [A,B]
</span>    <span class="n">area_b</span> <span class="o">=</span> <span class="p">((</span><span class="n">box_b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">box_b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
              <span class="p">(</span><span class="n">box_b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">box_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># [A,B]
</span>    <span class="n">union</span> <span class="o">=</span> <span class="n">area_a</span> <span class="o">+</span> <span class="n">area_b</span> <span class="o">-</span> <span class="n">inter</span>
    <span class="k">return</span> <span class="n">inter</span> <span class="o">/</span> <span class="n">union</span>  <span class="c1"># [A,B]
</span>
<span class="k">class</span> <span class="nc">Compose</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Composes several augmentations together.
    Args:
        transforms (List[Transform]): list of transforms to compose.
    Example:
</span><span class="gp">        &gt;&gt;&gt;</span> <span class="n">augmentations</span><span class="p">.</span><span class="nc">Compose</span><span class="p">([</span>
        <span class="o">&gt;&gt;&gt;</span>     <span class="n">transforms</span><span class="p">.</span><span class="nc">CenterCrop</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
        <span class="o">&gt;&gt;&gt;</span>     <span class="n">transforms</span><span class="p">.</span><span class="nc">ToTensor</span><span class="p">(),</span>
        <span class="o">&gt;&gt;&gt;</span> <span class="p">])</span>
    <span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">transforms</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">transforms</span><span class="p">:</span>
            <span class="n">img</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nf">t</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>


<span class="k">class</span> <span class="nc">ConvertFromInts</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 图像变换到float32
</span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">SubtractMeans</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 图像减去均值
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">mean</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">-=</span> <span class="n">self</span><span class="p">.</span><span class="n">mean</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">ToAbsoluteCoords</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># bbox从相对坐标变换到绝对坐标
</span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">shape</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">width</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">width</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">height</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="n">height</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">ToPercentCoords</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 变换到相对坐标
</span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">shape</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">width</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">width</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">height</span>
        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">/=</span> <span class="n">height</span>

        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">Resize</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># resize图像到宽高均为300
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">RandomSaturation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 在hsv色彩空间中调整图像饱和度（实际为饱和度通道乘以0.5-1.5的随机系数）
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span>
        <span class="n">self</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span>
        <span class="k">assert</span> <span class="n">self</span><span class="p">.</span><span class="n">upper</span> <span class="o">&gt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span> <span class="sh">"</span><span class="s">contrast upper must be &gt;= lower.</span><span class="sh">"</span>
        <span class="k">assert</span> <span class="n">self</span><span class="p">.</span><span class="n">lower</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">"</span><span class="s">contrast lower must be non-negative.</span><span class="sh">"</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">upper</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">RandomHue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 在hsv色彩空间中调整图像色度（实际为色度通道加上-delta到delta内的随机值）
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">18.0</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">delta</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">delta</span> <span class="o">&lt;=</span> <span class="mf">360.0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">self</span><span class="p">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">delta</span><span class="p">)</span>
            <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">360.0</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">360.0</span>
            <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">360.0</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">RandomLightingNoise</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 随机交换图像通道
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">perms</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                      <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                      <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">swap</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">perms</span><span class="p">[</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">perms</span><span class="p">))]</span>
            <span class="n">shuffle</span> <span class="o">=</span> <span class="nc">SwapChannels</span><span class="p">(</span><span class="n">swap</span><span class="p">)</span>  <span class="c1"># shuffle channels    # 随机交换通道调用的函数
</span>            <span class="n">image</span> <span class="o">=</span> <span class="nf">shuffle</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">ConvertColor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 图像从current色彩空间变换到transform色彩空间
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="sh">'</span><span class="s">BGR</span><span class="sh">'</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="sh">'</span><span class="s">HSV</span><span class="sh">'</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="n">self</span><span class="p">.</span><span class="n">current</span> <span class="o">=</span> <span class="n">current</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">current</span> <span class="o">==</span> <span class="sh">'</span><span class="s">BGR</span><span class="sh">'</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">transform</span> <span class="o">==</span> <span class="sh">'</span><span class="s">HSV</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">COLOR_BGR2HSV</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">self</span><span class="p">.</span><span class="n">current</span> <span class="o">==</span> <span class="sh">'</span><span class="s">HSV</span><span class="sh">'</span> <span class="ow">and</span> <span class="n">self</span><span class="p">.</span><span class="n">transform</span> <span class="o">==</span> <span class="sh">'</span><span class="s">BGR</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="nf">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="p">.</span><span class="n">COLOR_HSV2BGR</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">NotImplementedError</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">RandomContrast</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 图像对比度调整（实际为图像乘以一个0.5到1.5之内的随机的系数）
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span>
        <span class="n">self</span><span class="p">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span>
        <span class="k">assert</span> <span class="n">self</span><span class="p">.</span><span class="n">upper</span> <span class="o">&gt;=</span> <span class="n">self</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span> <span class="sh">"</span><span class="s">contrast upper must be &gt;= lower.</span><span class="sh">"</span>
        <span class="k">assert</span> <span class="n">self</span><span class="p">.</span><span class="n">lower</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">"</span><span class="s">contrast lower must be non-negative.</span><span class="sh">"</span>

    <span class="c1"># expects float image
</span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">lower</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">upper</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">*=</span> <span class="n">alpha</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">RandomBrightness</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>    <span class="c1"># 图像亮度调整（实际为亮度通道加上-delta到delta内的随机值）
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mi">32</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">delta</span> <span class="o">&gt;=</span> <span class="mf">0.0</span>
        <span class="k">assert</span> <span class="n">delta</span> <span class="o">&lt;=</span> <span class="mf">255.0</span>
        <span class="n">self</span><span class="p">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">self</span><span class="p">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">delta</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">+=</span> <span class="n">delta</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">ToCV2Image</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tensor</span><span class="p">.</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">().</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">).</span><span class="nf">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">ToTensor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">cvimage</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="n">cvimage</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)).</span><span class="nf">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">RandomSampleCrop</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>    <span class="c1"># 随机裁剪，并对相应的gt box进行变换
</span>    <span class="sh">"""</span><span class="s">Crop
    Arguments:
        img (Image): the image being input during training
        boxes (Tensor): the original bounding boxes in pt form
        labels (Tensor): the class labels for each bbox
        mode (float tuple): the min and max jaccard overlaps
    Return:
        (img, boxes, classes)
            img (Image): the cropped image
            boxes (Tensor): the adjusted bounding boxes in pt form
            labels (Tensor): the class labels for each bbox
    </span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">sample_options</span> <span class="o">=</span> <span class="p">(</span>
            <span class="c1"># using entire original input image
</span>            <span class="bp">None</span><span class="p">,</span>
            <span class="c1"># sample a patch s.t. MIN jaccard w/ obj in .1,.3,.4,.7,.9
</span>            <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>   <span class="c1"># min_iou, max_iou
</span>            <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
            <span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
            <span class="c1"># randomly sample a patch
</span>            <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">shape</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">sample_options</span><span class="p">)</span>   <span class="c1"># randomly choose a mode  # 从self.sample_options随机选一个
</span>            <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

            <span class="n">min_iou</span><span class="p">,</span> <span class="n">max_iou</span> <span class="o">=</span> <span class="n">mode</span>
            <span class="k">if</span> <span class="n">min_iou</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">min_iou</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">-inf</span><span class="sh">'</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_iou</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">max_iou</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">'</span><span class="s">inf</span><span class="sh">'</span><span class="p">)</span>

            <span class="c1"># max trails (50)
</span>            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>
                <span class="n">current_image</span> <span class="o">=</span> <span class="n">image</span>

                <span class="n">w</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>   <span class="c1"># 随机宽高
</span>                <span class="n">h</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">height</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

                <span class="c1"># aspect ratio constraint b/t .5 &amp; 2
</span>                <span class="k">if</span> <span class="n">h</span> <span class="o">/</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="ow">or</span> <span class="n">h</span> <span class="o">/</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>   <span class="c1"># 保证图像宽高比在0.5到2之间
</span>                    <span class="k">continue</span>

                <span class="n">left</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span>   <span class="c1"># 裁剪的左上角位置
</span>                <span class="n">top</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span>
                <span class="n">rect</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="nf">int</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nf">int</span><span class="p">(</span><span class="n">top</span><span class="p">),</span> <span class="nf">int</span><span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">w</span><span class="p">),</span> <span class="nf">int</span><span class="p">(</span><span class="n">top</span><span class="o">+</span><span class="n">h</span><span class="p">)])</span>   <span class="c1"># 裁剪的区域   # convert to integer rect x1,y1,x2,y2
</span>                <span class="n">overlap</span> <span class="o">=</span> <span class="nf">jaccard_numpy</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">rect</span><span class="p">)</span>   <span class="c1"># 计算gt box和裁剪区域的iou   # calculate IoU (jaccard overlap) b/t the cropped and gt boxes
</span>
                <span class="c1"># is min and max overlap constraint satisfied? if not try again
</span>                <span class="k">if</span> <span class="n">overlap</span><span class="p">.</span><span class="nf">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_iou</span> <span class="ow">and</span> <span class="n">max_iou</span> <span class="o">&lt;</span> <span class="n">overlap</span><span class="p">.</span><span class="nf">max</span><span class="p">():</span>    <span class="c1"># 保证裁剪区域iou满足条件
</span>                    <span class="k">continue</span>

                <span class="n">current_image</span> <span class="o">=</span> <span class="n">current_image</span><span class="p">[</span><span class="n">rect</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">rect</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">rect</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">rect</span><span class="p">[</span><span class="mi">2</span><span class="p">],:]</span>  <span class="c1"># 裁剪图像  # cut the crop from the image 
</span>                
                <span class="n">centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span> <span class="o">/</span> <span class="mf">2.0</span>     <span class="c1"># 裁剪前的目标中心   # keep overlap with gt box IF center in sampled patch
</span>                <span class="n">m1</span> <span class="o">=</span> <span class="p">(</span><span class="n">rect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">rect</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">centers</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c1"># 得到裁剪后起点在裁剪前目标左上侧的gt box的mask  # mask in all gt boxes that above and to the left of centers
</span>                <span class="n">m2</span> <span class="o">=</span> <span class="p">(</span><span class="n">rect</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">rect</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">centers</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c1"># 得到裁剪后终点在裁剪前目标右下侧的gt box的mask  # mask in all gt boxes that under and to the right of centers
</span>                <span class="n">mask</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">*</span> <span class="n">m2</span>    <span class="c1"># 得到裁剪后起点在裁剪前目标左上侧、终点在裁剪后图像右下侧的gt box的mask  # mask in that both m1 and m2 are true
</span>                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">.</span><span class="nf">any</span><span class="p">():</span>   <span class="c1"># 不存在满足条件的mask吗，则continue   # have any valid boxes? try again if not
</span>                    <span class="k">continue</span>
               
                <span class="n">current_boxes</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:].</span><span class="nf">copy</span><span class="p">()</span>   <span class="c1"># 得到满足条件的gt box    # take only matching gt boxes
</span>                <span class="n">current_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>           <span class="c1"># 得到满足条件的labels   # take only matching gt labels
</span>                <span class="n">current_boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">current_boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">rect</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>   <span class="c1"># 不能超出裁剪后的rect的边界  # should we use the box left and top corner or the crop's
</span>                <span class="n">current_boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rect</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>     <span class="c1"># 减去裁剪时的起点，得到裁剪后的gt box的起点坐标  # adjust to crop (by substracting crop's left,top)
</span>                <span class="n">current_boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">current_boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:],</span> <span class="n">rect</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>   <span class="c1"># 不能超出裁剪后的rect的边界
</span>                <span class="n">current_boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-=</span> <span class="n">rect</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>     <span class="c1"># 减去裁剪时的终点，得到裁剪后的gt box的终点坐标  # adjust to crop (by substracting crop's left,top)
</span>
                <span class="k">return</span> <span class="n">current_image</span><span class="p">,</span> <span class="n">current_boxes</span><span class="p">,</span> <span class="n">current_labels</span>   <span class="c1"># 有满足条件的裁剪后图像时，则直接返回
</span>
<span class="k">class</span> <span class="nc">Expand</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>  <span class="c1"># 对图像进行随机扩大（非放大。扩大是图像粘贴到更大的背景上，粘贴的图像本身未放大）并填充mean
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">mean</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

        <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">shape</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="o">*</span><span class="n">ratio</span> <span class="o">-</span> <span class="n">width</span><span class="p">)</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="o">*</span><span class="n">ratio</span> <span class="o">-</span> <span class="n">height</span><span class="p">)</span>

        <span class="n">expand_image</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="nf">int</span><span class="p">(</span><span class="n">height</span><span class="o">*</span><span class="n">ratio</span><span class="p">),</span> <span class="nf">int</span><span class="p">(</span><span class="n">width</span><span class="o">*</span><span class="n">ratio</span><span class="p">),</span> <span class="n">depth</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="p">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">expand_image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">mean</span>
        <span class="n">expand_image</span><span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">top</span><span class="p">):</span><span class="nf">int</span><span class="p">(</span><span class="n">top</span> <span class="o">+</span> <span class="n">height</span><span class="p">),</span> <span class="nf">int</span><span class="p">(</span><span class="n">left</span><span class="p">):</span><span class="nf">int</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">width</span><span class="p">)]</span> <span class="o">=</span> <span class="n">image</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">expand_image</span>

        <span class="n">boxes</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>    <span class="c1"># 扩大时，对bbx信息也进行相应修改
</span>        <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nf">int</span><span class="p">(</span><span class="n">top</span><span class="p">))</span>    <span class="c1"># 修改坐标起点
</span>        <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">+=</span> <span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nf">int</span><span class="p">(</span><span class="n">top</span><span class="p">))</span>    <span class="c1"># 修改坐标终点
</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span>

<span class="k">class</span> <span class="nc">RandomMirror</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 随机对图像镜像
</span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">boxes</span> <span class="o">=</span> <span class="n">boxes</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
            <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">width</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">classes</span>

<span class="k">class</span> <span class="nc">SwapChannels</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 随机交换通道调用的函数
</span>    <span class="sh">"""</span><span class="s">Transforms a tensorized image by swapping the channels in the order
     specified in the swap tuple.
    Args:
        swaps (int triple): final order of channels
            eg: (2, 1, 0)
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">swaps</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">swaps</span> <span class="o">=</span> <span class="n">swaps</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Args:
            image (Tensor): image tensor to be transformed
        Return:
            a tensor with channels swapped according to swap
        </span><span class="sh">"""</span>
        <span class="c1"># if torch.is_tensor(image):
</span>        <span class="c1">#     image = image.data.cpu().numpy()
</span>        <span class="c1"># else:
</span>        <span class="c1">#     image = np.array(image)
</span>        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">self</span><span class="p">.</span><span class="n">swaps</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">image</span>

<span class="k">class</span> <span class="nc">PhotometricDistort</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># 对图像进行失真操作，如亮度、对比度调整等
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">pd</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nc">RandomContrast</span><span class="p">(),</span>               <span class="c1"># 图像对比度调整（实际为图像乘以一个0.5到1.5之内的随机的系数）
</span>            <span class="nc">ConvertColor</span><span class="p">(</span><span class="n">transform</span><span class="o">=</span><span class="sh">'</span><span class="s">HSV</span><span class="sh">'</span><span class="p">),</span>  <span class="c1"># 图像从RGB色彩空间变换到HSV色彩空间
</span>            <span class="nc">RandomSaturation</span><span class="p">(),</span>             <span class="c1"># 在hsv色彩空间中调整图像饱和度（实际为饱和度通道乘以0.5-1.5的随机系数）
</span>            <span class="nc">RandomHue</span><span class="p">(),</span>                    <span class="c1"># 在hsv色彩空间中调整图像色度（实际为色度通道加上-delta到delta内的随机值）
</span>            <span class="nc">ConvertColor</span><span class="p">(</span><span class="n">current</span><span class="o">=</span><span class="sh">'</span><span class="s">HSV</span><span class="sh">'</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="sh">'</span><span class="s">BGR</span><span class="sh">'</span><span class="p">),</span>   <span class="c1"># 图像从HSV色彩空间变换到RGB色彩空间
</span>            <span class="nc">RandomContrast</span><span class="p">()</span>                <span class="c1"># 图像对比度调整（实际为图像乘以一个0.5到1.5之内的随机的系数）
</span>        <span class="p">]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rand_brightness</span> <span class="o">=</span> <span class="nc">RandomBrightness</span><span class="p">()</span>           <span class="c1"># 图像亮度调整（实际为亮度通道加上-delta到delta内的随机值）
</span>        <span class="n">self</span><span class="p">.</span><span class="n">rand_light_noise</span> <span class="o">=</span> <span class="nc">RandomLightingNoise</span><span class="p">()</span>       <span class="c1"># 随机交换图像通道
</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">rand_brightness</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>   <span class="c1"># 先随机调整图像亮度
</span>        <span class="k">if</span> <span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">distort</span> <span class="o">=</span> <span class="nc">Compose</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">pd</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>    <span class="c1"># 然后对图像进行正向随机失真调整
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">distort</span> <span class="o">=</span> <span class="nc">Compose</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">pd</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>     <span class="c1"># 然后对图像进行反向随机失真调整
</span>        <span class="n">im</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nf">distort</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>     <span class="c1"># 对图像进行随机失真操作
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">rand_light_noise</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>    <span class="c1"># 最后对图像进行随机交换通道并返回
</span>
<span class="k">class</span> <span class="nc">SSDAugmentation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>   <span class="c1"># ssd的SSDAugmentation
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="p">(</span><span class="mi">104</span><span class="p">,</span> <span class="mi">117</span><span class="p">,</span> <span class="mi">123</span><span class="p">)):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">mean</span>   <span class="c1"># 均值
</span>        <span class="n">self</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">augment</span> <span class="o">=</span> <span class="nc">Compose</span><span class="p">([</span>
            <span class="nc">ConvertFromInts</span><span class="p">(),</span>        <span class="c1"># 图像变换到float32
</span>            <span class="nc">ToAbsoluteCoords</span><span class="p">(),</span>       <span class="c1"># bbox从相对坐标变换到绝对坐标（因下面某些变换要使用绝对坐标）
</span>            <span class="nc">PhotometricDistort</span><span class="p">(),</span>     <span class="c1"># 对图像进行失真操作，如亮度、对比度调整等
</span>            <span class="nc">Expand</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">mean</span><span class="p">),</span>        <span class="c1"># 对图像进行随机扩大（非放大。扩大是图像粘贴到更大的背景上，粘贴的图像本身未放大）并填充mean
</span>            <span class="nc">RandomSampleCrop</span><span class="p">(),</span>       <span class="c1"># 随机裁剪，并对相应的gt box进行变换
</span>            <span class="nc">RandomMirror</span><span class="p">(),</span>           <span class="c1"># 随机对图像镜像
</span>            <span class="nc">ToPercentCoords</span><span class="p">(),</span>        <span class="c1"># 从绝对坐标变换到相对坐标（因最终要使用相对坐标）
</span>            <span class="nc">Resize</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>        <span class="c1"># resize图像到宽高均为300
</span>            <span class="nc">SubtractMeans</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">mean</span><span class="p">)</span>  <span class="c1"># 图像减去均值。
</span>        <span class="p">])</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">augment</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">boxes</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
</pre></table></code></div></div></details><h3 id="p36-vocannotationtransform">P3.6 VOCAnnotationTransform</h3><p>VOCDetection参数中包含VOCAnnotationTransform，用于对标签进行变换，从实际标签映射到训练所需的标签。其在训练和测试阶段均使用。位于data/voc0712.py中。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre><td class="rouge-code"><pre><span class="n">VOC_CLASSES</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># always index 0    voc的对应类别
</span>    <span class="sh">'</span><span class="s">aeroplane</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">bicycle</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">bird</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">boat</span><span class="sh">'</span><span class="p">,</span>
    <span class="sh">'</span><span class="s">bottle</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">bus</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">car</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">cat</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">chair</span><span class="sh">'</span><span class="p">,</span>
    <span class="sh">'</span><span class="s">cow</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">diningtable</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">dog</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">horse</span><span class="sh">'</span><span class="p">,</span>
    <span class="sh">'</span><span class="s">motorbike</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">person</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">pottedplant</span><span class="sh">'</span><span class="p">,</span>
    <span class="sh">'</span><span class="s">sheep</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">sofa</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">train</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">tvmonitor</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># note: if you used our download scripts, this should be right
# VOC_ROOT = osp.join(HOME, "data/VOCdevkit/")
</span><span class="n">VOC_ROOT</span> <span class="o">=</span> <span class="n">osp</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">'</span><span class="s">D:/download</span><span class="sh">'</span><span class="p">,</span> <span class="sh">"</span><span class="s">data/VOCdevkit/</span><span class="sh">"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">VOCAnnotationTransform</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Transforms a VOC annotation into a Tensor of bbox coords and label index
    Initilized with a dictionary lookup of classnames to indexes

    Arguments:
        class_to_ind (dict, optional): dictionary lookup of classnames -&gt; indexes
            (default: alphabetic indexing of VOC</span><span class="sh">'</span><span class="s">s 20 classes)
        keep_difficult (bool, optional): keep difficult instances or not. (default: False)
        height (int): height
        width (int): width
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">class_to_ind</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keep_difficult</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">class_to_ind</span> <span class="o">=</span> <span class="n">class_to_ind</span> <span class="ow">or</span> <span class="nf">dict</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">VOC_CLASSES</span><span class="p">,</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">VOC_CLASSES</span><span class="p">))))</span>   <span class="c1"># 从数据库中的实际类别（如bicycle）变换到训练所需的id（0, 1...）
</span>        <span class="n">self</span><span class="p">.</span><span class="n">keep_difficult</span> <span class="o">=</span> <span class="n">keep_difficult</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Arguments:
            target (annotation) : the target annotation to be made usable will be an ET.Element
        Returns:
            a list containing lists of bounding boxes  [bbox coords, class name]
        </span><span class="sh">"""</span>
        <span class="c1"># 一张图像上可能有多个训练目标（如3个），每个会有如下信息：
</span>        <span class="c1"># &lt;object&gt;
</span>        <span class="c1"># &lt;name&gt;bicycle&lt;/name&gt;
</span>        <span class="c1"># &lt;pose&gt;Left&lt;/pose&gt;
</span>        <span class="c1"># &lt;truncated&gt;1&lt;/truncated&gt;
</span>        <span class="c1"># &lt;difficult&gt;0&lt;/difficult&gt;
</span>        <span class="c1"># &lt;bndbox&gt;
</span>        <span class="c1">#   &lt;xmin&gt;1&lt;/xmin&gt;
</span>        <span class="c1">#   &lt;ymin&gt;178&lt;/ymin&gt;
</span>        <span class="c1">#   &lt;xmax&gt;235&lt;/xmax&gt;
</span>        <span class="c1">#   &lt;ymax&gt;331&lt;/ymax&gt;
</span>        <span class="c1"># &lt;/bndbox&gt;
</span>        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">target</span><span class="p">.</span><span class="nf">iter</span><span class="p">(</span><span class="sh">'</span><span class="s">object</span><span class="sh">'</span><span class="p">):</span>   <span class="c1"># 一次遍历当前图像上每个目标
</span>            <span class="n">difficult</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sh">'</span><span class="s">difficult</span><span class="sh">'</span><span class="p">).</span><span class="n">text</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>   <span class="c1"># 对比xml中当前图像当前目标的difficult是否为1
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">self</span><span class="p">.</span><span class="n">keep_difficult</span> <span class="ow">and</span> <span class="n">difficult</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">).</span><span class="n">text</span><span class="p">.</span><span class="nf">lower</span><span class="p">().</span><span class="nf">strip</span><span class="p">()</span>   <span class="c1"># 当前目标的类别，如bicycle
</span>            <span class="n">bbox</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sh">'</span><span class="s">bndbox</span><span class="sh">'</span><span class="p">)</span>  <span class="c1"># 当前目标的bbox
</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">xmin</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">ymin</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">xmax</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">ymax</span><span class="sh">'</span><span class="p">]</span>   <span class="c1"># 当前目标的四个坐标
</span>            <span class="n">bndbox</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">pts</span><span class="p">):</span>
                <span class="n">cur_pt</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">bbox</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">pt</span><span class="p">).</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">cur_pt</span> <span class="o">=</span> <span class="n">cur_pt</span> <span class="o">/</span> <span class="n">width</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">cur_pt</span> <span class="o">/</span> <span class="n">height</span>   <span class="c1"># scale height or width  # 坐标归一化。
</span>                <span class="n">bndbox</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur_pt</span><span class="p">)</span>
            <span class="n">label_idx</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">class_to_ind</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>   <span class="c1"># 当前目标的类别映射到训练使用的实际类别（变换到0-n）。
</span>            <span class="n">bndbox</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">label_idx</span><span class="p">)</span>   <span class="c1"># bndbox中增加类别
</span>            <span class="n">res</span> <span class="o">+=</span> <span class="p">[</span><span class="n">bndbox</span><span class="p">]</span>  <span class="c1"># [xmin, ymin, xmax, ymax, label_ind]   # res中增加当前目标
</span>
        <span class="k">return</span> <span class="n">res</span>  <span class="c1"># 返回结果，如下：实际目标个数的二维矩阵：[[xmin, ymin, xmax, ymax, label_ind], ... ]
</span></pre></table></code></div></div></details><h3 id="p37-损失函数multiboxloss">P3.7 损失函数MultiBoxLoss</h3><p>位于layers/modules/multibox_loss.py。</p><h4 id="p371-multiboxloss">P3.7.1 MultiBoxLoss</h4><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MultiBoxLoss</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">SSD Weighted Loss Function
    Compute Targets:
        1) Produce Confidence Target Indices by matching  ground truth boxes with (default) </span><span class="sh">'</span><span class="s">priorboxes</span><span class="sh">'</span><span class="s"> that have jaccard index &gt; threshold parameter
           (default threshold: 0.5).
        2) Produce localization target by </span><span class="sh">'</span><span class="s">encoding</span><span class="sh">'</span><span class="s"> variance into offsets of ground truth boxes and their matched  </span><span class="sh">'</span><span class="s">priorboxes</span><span class="sh">'</span><span class="s">.
        3) Hard negative mining to filter the excessive number of negative examples that comes with using a large number of default bounding boxes.
           (default negative:positive ratio 3:1)
    Objective Loss:
        L(x,c,l,g) = (Lconf(x, c) + αLloc(x,l,g)) / N
        Where, Lconf is the CrossEntropy Loss and Lloc is the SmoothL1 Loss weighted by α which is set to 1 by cross val.
        Args:
            c: class confidences,   分类的置信度
            l: predicted boxes,     预测框
            g: ground truth boxes   gt box
            N: number of matched default boxes   匹配的default box数量
        See: https://arxiv.org/pdf/1512.02325.pdf for more details.
    </span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">overlap_thresh</span><span class="p">,</span> <span class="n">prior_for_matching</span><span class="p">,</span> <span class="n">bkg_label</span><span class="p">,</span> 
                 <span class="n">neg_mining</span><span class="p">,</span> <span class="n">neg_pos</span><span class="p">,</span> <span class="n">neg_overlap</span><span class="p">,</span> <span class="n">encode_target</span><span class="p">,</span> <span class="n">use_gpu</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">MultiBoxLoss</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">use_gpu</span> <span class="o">=</span> <span class="n">use_gpu</span>
        <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">num_classes</span>   <span class="c1"># 分类的类别数量
</span>        <span class="n">self</span><span class="p">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">overlap_thresh</span>  <span class="c1"># 重叠阈值  0.5
</span>        <span class="n">self</span><span class="p">.</span><span class="n">background_label</span> <span class="o">=</span> <span class="n">bkg_label</span>  <span class="c1"># 0
</span>        <span class="n">self</span><span class="p">.</span><span class="n">encode_target</span> <span class="o">=</span> <span class="n">encode_target</span>  <span class="c1"># False
</span>        <span class="n">self</span><span class="p">.</span><span class="n">use_prior_for_matching</span> <span class="o">=</span> <span class="n">prior_for_matching</span>   <span class="c1"># True
</span>        <span class="n">self</span><span class="p">.</span><span class="n">do_neg_mining</span> <span class="o">=</span> <span class="n">neg_mining</span>  <span class="c1"># True
</span>        <span class="n">self</span><span class="p">.</span><span class="n">negpos_ratio</span> <span class="o">=</span> <span class="n">neg_pos</span>  <span class="c1"># 3
</span>        <span class="n">self</span><span class="p">.</span><span class="n">neg_overlap</span> <span class="o">=</span> <span class="n">neg_overlap</span>  <span class="c1"># 0.5
</span>        <span class="n">self</span><span class="p">.</span><span class="n">variance</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="sh">'</span><span class="s">variance</span><span class="sh">'</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">predictions</span><span class="p">,</span> <span class="n">targets</span><span class="p">):</span>
        <span class="c1"># 训练阶段只会滤除和gt box的IoU小于阈值的，将这些设置为背景。而后难例挖掘，不会进行nms
</span>        <span class="sh">"""</span><span class="s">Multibox Loss
        Args:
            predictions (tuple): A tuple containing loc preds, conf preds, and prior boxes from SSD net.
                conf shape: torch.size(batch_size,num_priors,num_classes)
                loc shape: torch.size(batch_size,num_priors,4)
                priors shape: torch.size(num_priors,4)

            targets (tensor): Ground truth boxes and labels for a batch,
                shape: [batch_size,num_objs,5] (last idx is the label).
        </span><span class="sh">"""</span>
        <span class="c1"># loc_data：bs*N*4的坐标。此处为预测的密集坐标（预测的偏移）   N为密集框的数量
</span>        <span class="c1"># conf_data：bs*N*num_classes的分类结果。此处为预测的密集类别（此处为特征，无softmax计算概率）
</span>        <span class="c1"># priors：不同分辨率的密集先验坐标（输入图像宽高一样，因而共用先验坐标即可）：N*4。N个[cx, cy, w, h]。此处为密集先验坐标
</span>        <span class="n">loc_data</span><span class="p">,</span> <span class="n">conf_data</span><span class="p">,</span> <span class="n">priors</span> <span class="o">=</span> <span class="n">predictions</span>   <span class="c1">#  实际的目标信息
</span>        <span class="n">num</span> <span class="o">=</span> <span class="n">loc_data</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># batch size
</span>        <span class="n">priors</span> <span class="o">=</span> <span class="n">priors</span><span class="p">[:</span><span class="n">loc_data</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">:]</span>  <span class="c1"># 取前loc_data.size(1)个。实际上priors.size(0)=loc_data.size(1)，即都取了
</span>        <span class="n">num_priors</span> <span class="o">=</span> <span class="p">(</span><span class="n">priors</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># 密集目标的数量
</span>
        <span class="c1"># match priors (default boxes) and ground truth boxes
</span>        <span class="n">loc_t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">num_priors</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>    <span class="c1"># bs*密集目标的数量*4    密集真实框（类似anchor）rect信息
</span>        <span class="n">conf_t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">LongTensor</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">num_priors</span><span class="p">)</span>    <span class="c1"># bs*密集目标的数量    密集真实框label信息
</span>        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>     <span class="c1"># 依次对当前batch中每张图像prior box和gt box进行匹配
</span>            <span class="n">truths</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="n">idx</span><span class="p">][:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">data</span>   <span class="c1"># 当前图像的gt box，数量很少，可能就几个或者一两个，gt的前四列：bbox
</span>            <span class="n">labels</span> <span class="o">=</span> <span class="n">targets</span><span class="p">[</span><span class="n">idx</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">data</span>    <span class="c1"># 当前图像的gt label，数量很少，可能就几个或者一两个，gt的最后一列：label
</span>            <span class="n">defaults</span> <span class="o">=</span> <span class="n">priors</span><span class="p">.</span><span class="n">data</span>   <span class="c1"># 密集prior目标。特征图上每个分辨率的每个位置，均含有目标（一个位置含有多个rect，用于不同比例及不同大小），用于匹配。
</span>            <span class="c1"># match之后，得到多分辨率特征图上每个密集prior的信息（rect和label），同时将和gt的IoU小于阈值的prior box设置为负样本（对应类别conf_t[idx]设置为0）
</span>            <span class="nf">match</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">threshold</span><span class="p">,</span> <span class="n">truths</span><span class="p">,</span> <span class="n">defaults</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">variance</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">loc_t</span><span class="p">,</span> <span class="n">conf_t</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>  <span class="c1"># 将密集prior box和gt box进行匹配，得到当前图像密集prior box，并修改第idx个loc_t, conf_t
</span>        
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">use_gpu</span><span class="p">:</span>
            <span class="n">loc_t</span> <span class="o">=</span> <span class="n">loc_t</span><span class="p">.</span><span class="nf">cuda</span><span class="p">()</span>
            <span class="n">conf_t</span> <span class="o">=</span> <span class="n">conf_t</span><span class="p">.</span><span class="nf">cuda</span><span class="p">()</span>
        <span class="c1"># wrap targets
</span>        <span class="n">loc_t</span> <span class="o">=</span> <span class="nc">Variable</span><span class="p">(</span><span class="n">loc_t</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>     <span class="c1"># bs*N*4
</span>        <span class="n">conf_t</span> <span class="o">=</span> <span class="nc">Variable</span><span class="p">(</span><span class="n">conf_t</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>   <span class="c1"># bs*N
</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">conf_t</span> <span class="o">&gt;</span> <span class="mi">0</span>     <span class="c1"># 真实目标的mask  bs*N 
</span>        <span class="n">num_pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>   <span class="c1"># 当前batch中每个图像上真实目标的个数   # bs*1   此时每张图像上真实的目标不会太多，主要是和gt目标比较近的目标
</span>
        <span class="c1"># Localization Loss (Smooth L1)
</span>        <span class="c1"># Shape: [batch,num_priors,4]
</span>        <span class="n">pos_idx</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="nf">dim</span><span class="p">()).</span><span class="nf">expand_as</span><span class="p">(</span><span class="n">loc_data</span><span class="p">)</span>    <span class="c1">#  pos增加维度，实际为pos的mask  bs*N -&gt;   # bs*N*4
</span>        <span class="n">loc_p</span> <span class="o">=</span> <span class="n">loc_data</span><span class="p">[</span><span class="n">pos_idx</span><span class="p">].</span><span class="nf">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>   <span class="c1"># 得到当前batch中所有预测的坐标（此时没有bs了）  sum(num_pos)*4  如num_pos=[16,11,26,11,4,22,12,28], 则loc_p为130*4
</span>        <span class="n">loc_t</span> <span class="o">=</span> <span class="n">loc_t</span><span class="p">[</span><span class="n">pos_idx</span><span class="p">].</span><span class="nf">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>      <span class="c1"># 得到当前batch中所有真实的坐标（此时没有bs了）  sum(num_pos)*4  如num_pos=[16,11,26,11,4,22,12,28], 则loc_p为130*4
</span>        <span class="n">loss_l</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">smooth_l1_loss</span><span class="p">(</span><span class="n">loc_p</span><span class="p">,</span> <span class="n">loc_t</span><span class="p">,</span> <span class="n">size_average</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>   <span class="c1"># 正样本预测框和真实框的smooth l1损失
</span>
        <span class="c1"># Compute max conf across batch for hard negative mining   难例挖掘
</span>        <span class="n">batch_conf</span> <span class="o">=</span> <span class="n">conf_data</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span><span class="p">)</span>   <span class="c1"># reshanpe成 (bs*N) * self.num_classes，用于计算分类损失。此处为预测类别的特征
</span>        <span class="n">loss_c</span> <span class="o">=</span> <span class="nf">log_sum_exp</span><span class="p">(</span><span class="n">batch_conf</span><span class="p">)</span> <span class="o">-</span> <span class="n">batch_conf</span><span class="p">.</span><span class="nf">gather</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">conf_t</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1"># batch_conf.gather(1, conf_t.view(-1, 1))用于取出密集预测框实际label对应的特征（置信度）
</span>
        <span class="n">loss_c</span> <span class="o">=</span> <span class="n">loss_c</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># bs*N
</span>        <span class="c1"># Hard Negative Mining    以下为难例挖掘
</span>        <span class="n">loss_c</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># filter out pos boxes for now     去除正样本的损失，防止正样本影响负样本的选择
</span>        
        <span class="c1"># 假如loss_idx=[4 7 0 5 6 1 3 2]，则idx_rank=[2 5 7 6 0 3 4 1]，取idx_rank&lt;3作为mask，则mask=[1 0 0 0 1 0 0 1]，则data[mask]可以取到data的0,4,7个，即loss_idx的前3个
</span>        <span class="n">_</span><span class="p">,</span> <span class="n">loss_idx</span> <span class="o">=</span> <span class="n">loss_c</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>   <span class="c1">#  每个图像上负样本从难到易（loss由高到低）的索引    bs*N
</span>        <span class="n">_</span><span class="p">,</span> <span class="n">idx_rank</span> <span class="o">=</span> <span class="n">loss_idx</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># 对loss_idx排序，得到新的索引。见上面注释。由于loss_idx只是0-N的不同顺序，下面需要取loss_idx前num_neg个，loss_idx前几个的值即是loss_c的索引。对loss_idx排序取索引后得到的idx_rank作为mask，可通过其值&lt;num_neg得到原始数据的索引
</span>        <span class="n">num_pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="nf">long</span><span class="p">().</span><span class="nf">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>     <span class="c1"># 当前batch中每个图像上真实目标的个数   # bs*1   此时每张图像上真实的目标不会太多，主要是和gt目标比较近的目标
</span>        <span class="n">num_neg</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">clamp</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">negpos_ratio</span><span class="o">*</span><span class="n">num_pos</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">pos</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># 当前batch中每个图像上负样本的个数
</span>        <span class="n">neg</span> <span class="o">=</span> <span class="n">idx_rank</span> <span class="o">&lt;</span> <span class="n">num_neg</span><span class="p">.</span><span class="nf">expand_as</span><span class="p">(</span><span class="n">idx_rank</span><span class="p">)</span>    <span class="c1"># 选择的负样本的mask
</span>
        <span class="c1"># Confidence Loss Including Positive and Negative Examples
</span>        <span class="n">pos_idx</span> <span class="o">=</span> <span class="n">pos</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">expand_as</span><span class="p">(</span><span class="n">conf_data</span><span class="p">)</span>    <span class="c1"># 正样本索引
</span>        <span class="n">neg_idx</span> <span class="o">=</span> <span class="n">neg</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">expand_as</span><span class="p">(</span><span class="n">conf_data</span><span class="p">)</span>    <span class="c1"># 负样本索引
</span>        <span class="n">conf_p</span> <span class="o">=</span> <span class="n">conf_data</span><span class="p">[(</span><span class="n">pos_idx</span><span class="o">+</span><span class="n">neg_idx</span><span class="p">).</span><span class="nf">gt</span><span class="p">(</span><span class="mi">0</span><span class="p">)].</span><span class="nf">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">num_classes</span><span class="p">)</span>   <span class="c1"># 选中的预测的正样本和负样本的特征    (sum(num_pos)*(1+self.negpos_ratio))*self.num_classes  若loc_p为130*4（4为rect的坐标），则此处最多为520*self.num_classes
</span>        <span class="n">targets_weighted</span> <span class="o">=</span> <span class="n">conf_t</span><span class="p">[(</span><span class="n">pos</span><span class="o">+</span><span class="n">neg</span><span class="p">).</span><span class="nf">gt</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>     <span class="c1"># 选中的archor的正样本和负样本的label
</span>        <span class="n">loss_c</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">cross_entropy</span><span class="p">(</span><span class="n">conf_p</span><span class="p">,</span> <span class="n">targets_weighted</span><span class="p">,</span> <span class="n">size_average</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>   <span class="c1"># 使用CE计算预测特征（无需softmax）和真值label的交叉熵
</span>
        <span class="c1"># Sum of losses: L(x,c,l,g) = (Lconf(x, c) + αLloc(x,l,g)) / N
</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">num_pos</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">sum</span><span class="p">()</span>   <span class="c1"># 正样本个数
</span>        <span class="n">loss_l</span> <span class="o">/=</span> <span class="n">N</span>    <span class="c1"># 定位误差除以正样本个数
</span>        <span class="n">loss_c</span> <span class="o">/=</span> <span class="n">N</span>    <span class="c1"># 分类误差除以正样本个数
</span>        <span class="k">return</span> <span class="n">loss_l</span><span class="p">,</span> <span class="n">loss_c</span>   <span class="c1"># 返回定位误差和分类误差
</span></pre></table></code></div></div></details><h4 id="p372-match">P3.7.2 match</h4><p>计算损失时需要调用match将密集prior box和gt box匹配，得到当前图像密集prior box。其位于layers/box_utils.py。</p><details><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">point_form</span><span class="p">(</span><span class="n">boxes</span><span class="p">):</span>  <span class="c1"># 从 [cx, cy, w, h]变换到[xmin, ymin, xmax, ymax]
</span>    <span class="sh">"""</span><span class="s"> Convert prior_boxes to (xmin, ymin, xmax, ymax) representation for comparison to point form ground truth data.
    Args:
        boxes: (tensor) center-size default boxes from priorbox layers.
    Return:
        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.
    </span><span class="sh">"""</span>
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>     <span class="c1"># xmin, ymin
</span>                     <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># xmax, ymax
</span>
<span class="k">def</span> <span class="nf">center_size</span><span class="p">(</span><span class="n">boxes</span><span class="p">):</span> <span class="c1"># 从 [xmin, ymin, xmax, ymax]变换到[cx, cy, w, h]
</span>    <span class="sh">"""</span><span class="s"> Convert prior_boxes to (cx, cy, w, h) representation for comparison to center-size form ground truth data.
    Args:
        boxes: (tensor) point_form boxes
    Return:
        boxes: (tensor) Converted xmin, ymin, xmax, ymax form of boxes.
    </span><span class="sh">"""</span>
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># cx, cy
</span>                     <span class="n">boxes</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">boxes</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># w, h
</span>
<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">):</span>   <span class="c1"># 计算两个rect的交集area
</span>    <span class="sh">"""</span><span class="s"> We resize both tensors to [A,B,2] without new malloc:
    [A,2] -&gt; [A,1,2] -&gt; [A,B,2]
    [B,2] -&gt; [1,B,2] -&gt; [A,B,2]
    Then we compute the area of intersect between box_a and box_b.
    Args:
      box_a: (tensor) bounding boxes, Shape: [A,4].
      box_b: (tensor) bounding boxes, Shape: [B,4].
    Return:
      (tensor) intersection area, Shape: [A,B].
    </span><span class="sh">"""</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">box_a</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">box_b</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">max_xy</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">min</span><span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:].</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">box_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:].</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># unsqueeze：增加一个维度
</span>    <span class="n">min_xy</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">].</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">box_b</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">].</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">expand</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">clamp</span><span class="p">((</span><span class="n">max_xy</span> <span class="o">-</span> <span class="n">min_xy</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inter</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inter</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>   <span class="c1"># 交集area  [box_a.size(0), box_b.size(0)]
</span>
<span class="k">def</span> <span class="nf">jaccard</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">):</span>   <span class="c1"># 计算两个rect的IoU
</span>    <span class="sh">"""</span><span class="s">Compute the jaccard overlap of two sets of boxes.  The jaccard overlap is simply the intersection over union of two boxes. 
    Here we operate on ground truth boxes and default boxes.
    E.g.:
        A ∩ B / A ∪ B = A ∩ B / (area(A) + area(B) - A ∩ B)
    Args:
        box_a: (tensor) Ground truth bounding boxes, Shape: [num_objects,4]
        box_b: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4]
    Return:
        jaccard overlap: (tensor) Shape: [box_a.size(0), box_b.size(0)]
    </span><span class="sh">"""</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">box_a</span><span class="p">,</span> <span class="n">box_b</span><span class="p">)</span>  <span class="c1"># 两个rect的交集的area
</span>    <span class="n">area_a</span> <span class="o">=</span> <span class="p">((</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">box_a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])).</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">expand_as</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>  <span class="c1"># [A,B]
</span>    <span class="n">area_b</span> <span class="o">=</span> <span class="p">((</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">box_b</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])).</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">expand_as</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>  <span class="c1"># [A,B]
</span>    <span class="n">union</span> <span class="o">=</span> <span class="n">area_a</span> <span class="o">+</span> <span class="n">area_b</span> <span class="o">-</span> <span class="n">inter</span>   <span class="c1"># 两个rect的并集area
</span>
    <span class="c1"># IoU  每一行代表box_a的某一个框和box_b的所有框的IoU；每一列代表box_b的某一个框和box_a的所有框的IoU；
</span>    <span class="k">return</span> <span class="n">inter</span> <span class="o">/</span> <span class="n">union</span>  <span class="c1"># [box_a.size(0), box_b.size(0)]  
</span>
<span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">truths</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">loc_t</span><span class="p">,</span> <span class="n">conf_t</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>  
    <span class="c1"># truths是gt目标，priors是在特征图上选择的archors（密集选择，因而每个尺度的特征图上某个点对应不同大小的目标）
</span>    <span class="c1"># 将密集目标（priors）和gt目标（truths）进行匹配，得到当前图像密集prior box，并修改第idx个loc_t, conf_t
</span>    <span class="sh">"""</span><span class="s">Match each prior box with the ground truth box of the highest jaccard overlap, encode the bounding boxes, 
    then return the matched indices corresponding to both confidence and location preds.
    Args:
        threshold: (float) The overlap threshold used when mathing boxes.            匹配时IoU的阈值
        truths: (tensor) Ground truth boxes, Shape: [num_obj, 4].                    gt box 当前图像实际目标数量*4
        priors: (tensor) Prior boxes from priorbox layers, Shape: [num_priors,4].    当前图像密集目标数量*4
        variances: (tensor) Variances corresponding to each prior coord, Shape: [2]或者[1].
        labels: (tensor) All the class labels for the image, Shape: [num_obj].       当前图像实际目标label
        loc_t: (tensor) Tensor to be filled w/ endcoded location targets.            待修改的返回值，图像密集prior box的位置信息
        conf_t: (tensor) Tensor to be filled w/ matched indices for conf preds.      待修改的返回值，图像密集prior box的类别信息
        idx: (int) current batch index
    Return:
        The matched indices corresponding to 1)location and 2)confidence preds.
    </span><span class="sh">"""</span>
    <span class="c1"># jaccard index   计算两个rect的IoU  每一行代表truths的某一个框和priors的所有框的IoU；每一列代表priors的某一个框和truths的所有框的IoU；
</span>    <span class="n">overlaps</span> <span class="o">=</span> <span class="nf">jaccard</span><span class="p">(</span><span class="n">truths</span><span class="p">,</span> <span class="nf">point_form</span><span class="p">(</span><span class="n">priors</span><span class="p">))</span>   <span class="c1"># overlaps：[truths.size(0), priors.size(0)]，如3*8732   truths.size(0)很小，priors.size(0)很大（因为是密集目标）
</span>
    <span class="c1"># (Bipartite Matching)   # 二分图匹配
</span>    
    <span class="n">best_prior_overlap</span><span class="p">,</span> <span class="n">best_prior_idx</span> <span class="o">=</span> <span class="n">overlaps</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># gt的每个框对应的密集先验priors的相应框的信息  [num_objects, 1] best prior for each ground truth
</span>    
    <span class="n">best_truth_overlap</span><span class="p">,</span> <span class="n">best_truth_idx</span> <span class="o">=</span> <span class="n">overlaps</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># 密集先验priors的每个框对应的gt的相应框的信息   [1,num_priors] best ground truth for each prior
</span>    <span class="n">best_truth_idx</span><span class="p">.</span><span class="nf">squeeze_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># 共num_priors个，密集目标，所以数量很大，如8732
</span>    <span class="n">best_truth_overlap</span><span class="p">.</span><span class="nf">squeeze_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 共num_priors个，密集目标，所以数量很大，如8732
</span>    <span class="n">best_prior_idx</span><span class="p">.</span><span class="nf">squeeze_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># 共num_obj个，实际目标，所以数量很少，如3
</span>    <span class="n">best_prior_overlap</span><span class="p">.</span><span class="nf">squeeze_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># 共num_obj个，实际目标，所以数量很少，如3
</span>    
    <span class="c1"># index_fill_:按照index（即best_prior_idx），将val（即2）的值填充best_truth_overlap的dim（即0）维度。
</span>    <span class="c1"># 保证密集先验priors框对应的gt一定最大。即确保密集先验priors在实际目标位置的框一定能对应到gt框
</span>    <span class="n">best_truth_overlap</span><span class="p">.</span><span class="nf">index_fill_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">best_prior_idx</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># ensure best prior  
</span>    <span class="c1"># TODO refactor: index  best_prior_idx with long tensor ensure every gt matches with its prior of max overlap
</span>    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">best_prior_idx</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>   <span class="c1"># 依次遍历每个gt框对应的先验框的索引（每张图上实际框很少，如3个），j为第几个实际目标
</span>        <span class="n">best_truth_idx</span><span class="p">[</span><span class="n">best_prior_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span>   <span class="c1"># 修改先验框priors对应gt框的索引（确保和best_truth_overlap.index_fill_所对应的目标一致）
</span>    <span class="n">matches</span> <span class="o">=</span> <span class="n">truths</span><span class="p">[</span><span class="n">best_truth_idx</span><span class="p">]</span>          <span class="c1"># Shape: [num_priors,4]   每个先验框priors匹配到的 gt rect，由于实际框很少，因而matches中有很多重复的rect（8732个框对应3个框，重复对应的很多）
</span>    <span class="n">conf</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">best_truth_idx</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c1"># Shape: [num_priors]   每个先验框priors匹配到的gt的类别
</span>    <span class="n">conf</span><span class="p">[</span><span class="n">best_truth_overlap</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># label as background   每个先验框priors匹配到的gt中那些和gt的IoU小于阈值的label设置为背景，只保留和实际框IoU较大的先验框作为目标（由于有重叠，因而保留的正样本密集框很少，如可能20来个，其他全是负样本，供之后nms）
</span>    <span class="n">loc</span> <span class="o">=</span> <span class="nf">encode</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">)</span>   <span class="c1"># 根据论文中公式，对真实框matches和先验框priors的偏移（offset）进行编码
</span>    <span class="n">loc_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>    <span class="c1"># [num_priors,4] encoded offsets to learn  修改当前batch第idx个真实框  loc_t：bs*N*4   loc：N*4   N为密集真实的数量，如8732
</span>    <span class="n">conf_t</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">conf</span>  <span class="c1"># [num_priors] top class label for each prior  修改当前batch第idx个输出结果   conf_t：bs*N  conf：N   N为密集真实的数量，如8732
</span>
<span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">matched</span><span class="p">,</span> <span class="n">priors</span><span class="p">,</span> <span class="n">variances</span><span class="p">):</span>   <span class="c1"># 根据公式进行编码
</span>    <span class="sh">"""</span><span class="s">Encode the variances from the priorbox layers into the ground truth boxes we have matched (based on jaccard overlap) with the prior boxes.
    Args:
        matched: (tensor) Coords of ground truth for each prior in point-form, Shape: [num_priors, 4].   每个先验框对应的gt框的rect  [xmin, ymin, xmax, ymax]
        priors: (tensor) Prior boxes in center-offset form, Shape: [num_priors,4].      每个先验框的rect   [cx, cy, w, h]
        variances: (list[float]) Variances of priorboxes
    Return:
        encoded boxes (tensor), Shape: [num_priors, 4]
    </span><span class="sh">"""</span>

    <span class="sh">'''</span><span class="s">
    g</span><span class="sh">'</span><span class="s">_x=(g_x-d_x)/(d_w*var_0)    y同理，将d_w换成d_h
    g</span><span class="sh">'</span><span class="s">_w=log(g_w/d_w)/var_1       h同理
    其中，g</span><span class="sh">'</span><span class="s">为实际的offset（此处返回值），g为gt坐标（此处matched），d为先验坐标（此处priors）
    </span><span class="sh">'''</span>
    <span class="n">g_cxcy</span> <span class="o">=</span> <span class="p">(</span><span class="n">matched</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">matched</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">priors</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>   <span class="c1"># 前半部分得到matched的框的中心，整体得到每个真实框中心的偏移   # dist b/t match center and prior's center
</span>    <span class="n">g_cxcy</span> <span class="o">/=</span> <span class="p">(</span><span class="n">variances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:])</span>   <span class="c1"># 编码真实框中心偏移   # encode variance
</span>    <span class="n">g_wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">matched</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">matched</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">priors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span>    <span class="c1"># 前半部分得到真实框的宽高，整体得到真实框wh和先验框wh的比值  # match wh / prior wh
</span>    <span class="n">g_wh</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">g_wh</span><span class="p">)</span> <span class="o">/</span> <span class="n">variances</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>   <span class="c1"># 编码真实框的wh
</span>    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">g_cxcy</span><span class="p">,</span> <span class="n">g_wh</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># [num_priors,4]    # 返回真实框编码后的结果  # return target for smooth_l1_loss
</span>
<span class="k">def</span> <span class="nf">log_sum_exp</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Utility function for computing log_sum_exp while determining
    This will be used to determine unaveraged confidence loss across all examples in a batch.
    Args:
        x (Variable(tensor)): conf_preds from conf layers
    </span><span class="sh">"""</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_max</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span> <span class="o">+</span> <span class="n">x_max</span>
</pre></table></code></div></div></details></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div class="post-tags"> <span>标签(Tags)</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a href="/tags/deep-learning/" class="post-tag no-text-decoration" >deep learning</a> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >algorithm</a> <a href="/tags/detection/" class="post-tag no-text-decoration" >detection</a></div></div><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/UbuntuAgent/">Ubuntu使用代理</a><li><a href="/posts/SunloginDisconnectWin10/">windows10使用向日葵访问ubuntu 20.04显示连接已断开</a><li><a href="/posts/TimeWin10Ubuntu/">windows10和ubuntu双系统的时间差</a><li><a href="/posts/markdown/">markdown基本语法</a><li><a href="/posts/MountDriverInWin10Ubuntu/">windows10的ubuntu子系统挂载移动硬盘</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/deep-learning/">deep learning</a> <a class="post-tag" href="/tags/detection/">detection</a> <a class="post-tag" href="/tags/normalization/">normalization</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/transformers/">transformers</a> <a class="post-tag" href="/tags/demo/">demo</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h6 align="left"><br>未设置提醒，因而不一定能看到回复，见谅</h6><div class="post-navigation d-flex justify-content-between"> <a href="/posts/CenterNet/" class="btn btn-outline-primary" prompt="Older"><p>CenterNet Objects as Points</p></a> <a href="/posts/CornerNet/" class="btn btn-outline-primary" prompt="Newer"><p>CornerNet: Detecting Objects as Paired Keypoints</p></a></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> <script src="https://code.jquery.com/jquery-3.2.0.min.js"></script> <script>AV.initialize("7DUQTBuCCKLjnutJOa6ko5cn-MdYXbMMI", "lxmthTQ8ESa2HrVQiIVyXtYo");</script> <script> //新增访问次数 function addCount(Counter) { // 页面（博客文章）中的信息：leancloud_visitors // id为page.url， data-flag-title为page.title var $visitors = $(".leancloud_visitors"); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); var query = new AV.Query(Counter); // 只根据文章的url查询LeanCloud服务器中的数据 query.equalTo("post_url", url); query.find({ success: function(results) { if (results.length > 0) {//说明LeanCloud中已经记录了这篇文章 var counter = results[0]; counter.fetchWhenSave(true); counter.increment("visited_times");// 将点击次数加1 counter.save(null, { success: function(counter) { var $element = $(document.getElementById(url)); var newTimes = counter.get('visited_times'); $element.find('.leancloud-visitors-count').text(newTimes); }, error: function(counter, error) { console.log('Failed to save Visitor num, with error message: ' + error.message); } }); } else { // 执行这里，说明LeanCloud中还没有记录此文章 var newcounter = new Counter(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newcounter.setACL(acl); /* End Set ACL */ newcounter.set("post_title", title);// 把文章标题 newcounter.set("post_url", url); // 文章url newcounter.set("visited_times", 1); // 初始点击次数：1次 newcounter.save(null, { // 上传到LeanCloud服务器中 success: function(newcounter) { var $element = $(document.getElementById(url)); var newTimes = newcounter.get('visited_times'); $element.find('.leancloud-visitors-count').text(newTimes); }, error: function(newcounter, error) { console.log('Failed to create'); } }); } }, error: function(error) { console.log('Error:' + error.code + " " + error.message); } }); } //仅根据url和title查出当前访问次数，不做+1操作 function showCount(Counter) { var $visitors = $(".leancloud_visitors"); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); var query = new AV.Query(Counter); // 只根据文章的url查询LeanCloud服务器中的数据 query.equalTo("post_url", url); query.find({ success: function(results) { if (results.length > 0) {//说明LeanCloud中已经记录了这篇文章 var counter = results[0]; var $element = $(document.getElementById(url)); var newTimes = counter.get('visited_times'); $element.find('.leancloud-visitors-count').text(newTimes); } else { //如果表里没查到记录，那就是异常情况了 console.log('异常情况，不应该没记录的'); } }, error: function(error) { console.log('Error:' + error.code + " " + error.message); } }); } //调用API获取IP function getVisitorIpAndJudge() { var ip; var options = { type: 'POST', dataType: "json", //async: false, //jquery3中可以直接使用回调函数，不用再指定async url: "https://freegeoip.net/json/?callback=?" }; $.ajax(options) .done(function(data, textStatus, jqXHR) { if(textStatus == "success") { ip = data.ip; } judgeVisitor(ip) }); } //判断访客是否已访问过该文章，及访问时间，符合条件则增加一次访问次数 function judgeVisitor(ip) { var Counter = AV.Object.extend("visited_times"); var Visitor = AV.Object.extend("visitors_record"); var $postInfo = $(".leancloud_visitors"); var post_url = $postInfo.attr('id').trim(); var query = new AV.Query(Visitor); query.equalTo("visitor_ip", ip); query.equalTo("post_url", post_url); query.find({ success: function(results) { if (results.length > 0) { console.log('该IP已访问过该文章'); var oldVisitor = results[0]; var lastTime = oldVisitor.updatedAt; var curTime = new Date(); var timePassed = curTime.getTime() - lastTime.getTime(); if(timePassed > 1 * 60 * 1000) { console.log('距离该IP上一次访问该文章已超过了1分钟，更新访问记录，并增加访问次数'); addCount(Counter); oldVisitor.fetchWhenSave(true); oldVisitor.save(null, { success: function(oldVisitor) { }, error: function(oldVisitor, error) { console.log('Failed to save visitor record, with error message: ' + error.message); } }); } else { console.log('这是该IP 1分钟内重复访问该文章，不更新访问记录，不增加访问次数'); showCount(Counter); } } else { console.log('该IP第一次访问该文章，保存新的访问记录，并增加访问次数'); addCount(Counter); var newVisitor = new Visitor(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newVisitor.setACL(acl); newVisitor.set("visitor_ip", ip); newVisitor.set("post_url", post_url); newVisitor.save(null, { // 上传到LeanCloud服务器中 success: function(newVisitor) { }, error: function(newVisitor, error) { console.log('Failed to create visitor record, with error message: ' + error.message); } }); } }, error: function(error) { console.log('Error:' + error.code + " " + error.message); addCount(Counter); } }); } $(function() { if ($('.leancloud_visitors').length == 1) { // 文章页面，调用判断方法，对符合条件的访问增加访问次数 getVisitorIpAndJudge(); } else if ($('.post-link').length > 1){ // 首页 暂未使用 // showHitCount(Counter); } }); </script><div> <span id="/posts/SSD/" class="leancloud_visitors" data-flag-title="SSD Single Shot MultiBox Detector"> <a href="#">Pageviews:<span class="leancloud-visitors-count"></span> times</a></span></div><h4 align="left">用户留言：</h4><div id="comments"></div><script src='//unpkg.com/valine/dist/Valine.min.js'></script> <script> new Valine({ av: AV, el: '#comments', app_id: '7DUQTBuCCKLjnutJOa6ko5cn-MdYXbMMI', app_key: 'lxmthTQ8ESa2HrVQiIVyXtYo', placeholder: '', avatar: 'mp', notify: 'true', verify: 'true', recordIP: 'true', enableQQ: 'true', visitor: true }); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#main > div.row:first-child > div:first-child img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="">darkknightzh</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/deep-learning/">deep learning</a> <a class="post-tag" href="/tags/detection/">detection</a> <a class="post-tag" href="/tags/normalization/">normalization</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/transformers/">transformers</a> <a class="post-tag" href="/tags/demo/">demo</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://darkknightzh.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
