<!DOCTYPE html><html lang="en-US" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="目标检测中的一些评价参数" /><meta name="author" content="darkknightzh" /><meta property="og:locale" content="en_US" /><meta name="description" content="仅供学习交流使用，错误之处在所难免，欢迎指正." /><meta property="og:description" content="仅供学习交流使用，错误之处在所难免，欢迎指正." /><link rel="canonical" href="https://darkknightzh.github.io/posts/detectionMetrics/" /><meta property="og:url" content="https://darkknightzh.github.io/posts/detectionMetrics/" /><meta property="og:site_name" content="darkknightzh" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-09-13T16:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="目标检测中的一些评价参数" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"darkknightzh"},"dateModified":"2021-09-13T16:00:00+08:00","datePublished":"2021-09-13T16:00:00+08:00","description":"仅供学习交流使用，错误之处在所难免，欢迎指正.","headline":"目标检测中的一些评价参数","mainEntityOfPage":{"@type":"WebPage","@id":"https://darkknightzh.github.io/posts/detectionMetrics/"},"url":"https://darkknightzh.github.io/posts/detectionMetrics/"}</script><title>目标检测中的一些评价参数 | darkknightzh</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] }, // chtml: { displayAlign: 'left' } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">darkknightzh</a></div><div class="site-subtitle font-italic">忘记一个人，从忘记那个声音开始</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>主页</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>时间轴</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/darkknightzh" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>目标检测中的一些评价参数</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>目标检测中的一些评价参数</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> darkknightzh </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Sep 13, 2021, 4:00 PM +0800" prep="on" > Sep 13, 2021 <i class="unloaded">2021-09-13T16:00:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4509 words">25 min</span></div></div><div class="post-content"><style> h1 { border-bottom: none }</style><p>转载请注明出处：</p><p><a href="https://darkknightzh.github.io/posts/detectionMetrics">https://darkknightzh.github.io/posts/detectionMetrics</a></p><p>参考网址：</p><p>（基本上都是从下面网址中复制，因而可以直接去相应网址查看）</p><p><a href="https://blog.csdn.net/CherDW/article/details/55813071">https://blog.csdn.net/CherDW/article/details/55813071</a></p><p><a href="https://www.jianshu.com/p/5df19746daf9">https://www.jianshu.com/p/5df19746daf9</a></p><p><a href="https://blog.csdn.net/sinat_42239797/article/details/93651594">https://blog.csdn.net/sinat_42239797/article/details/93651594</a></p><p><a href="https://blog.csdn.net/u013063099/article/details/80964865">https://blog.csdn.net/u013063099/article/details/80964865</a></p><p><a href="https://blog.paperspace.com/mean-average-precision/">https://blog.paperspace.com/mean-average-precision/</a></p><p><a href="https://pro.arcgis.com/es/pro-app/latest/tool-reference/image-analyst/how-compute-accuracy-for-object-detection-works.htm">https://pro.arcgis.com/es/pro-app/latest/tool-reference/image-analyst/how-compute-accuracy-for-object-detection-works.htm</a></p><p><a href="https://blog.csdn.net/xskxushaokai/article/details/89419025">https://blog.csdn.net/xskxushaokai/article/details/89419025</a></p><p><br /></p><h2 id="分类准确率accuracy_score"><strong>分类准确率accuracy_score</strong></h2><p>分类准确率分数是指所有的预测正确（正类负类）的占总的比重。它不能告诉你响应值的潜在分布，并且它也不能告诉你分类器犯错的类型。</p>\[Accuracy=\frac{TP+TN}{TP+TN+FP+FN}\]<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="nf">accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></table></code></div></div><p>normalize：默认值为True，返回正确分类的比例；如果为False，返回正确分类的样本数</p><div class="language-terminal highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>import numpy as np
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>from sklearn.metrics import accuracy_score
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y_pred <span class="o">=</span> <span class="o">[</span>0, 2, 1, 3]
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y_true <span class="o">=</span> <span class="o">[</span>0, 1, 2, 3]
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>accuracy_score<span class="o">(</span>y_true, y_pred<span class="o">)</span>
<span class="go">0.5
</span><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>accuracy_score<span class="o">(</span>y_true, y_pred, <span class="nv">normalize</span><span class="o">=</span>False<span class="o">)</span>
<span class="go">2 
</span></pre></table></code></div></div><h2 id="精确率precision"><strong>精确率Precision</strong></h2><p>查准率。即正确预测为正的占全部预测为正的比例。</p>\[Precison=\frac{TP}{TP+FP}\]<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">sklearn.metrics</span> <span class="kn">import</span> <span class="n">precision_score</span>
<span class="n">precision</span> <span class="o">=</span> <span class="nf">precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_predict</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="召回率recall_score"><strong>召回率recall_score</strong></h2><p>查全率。即正确预测为正的占全部实际为正的比例。</p>\[Precison=\frac{TP}{TP+FN}\]<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">klearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="nf">recall_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">average</span><span class="o">=</span><span class="sh">'</span><span class="s">binary</span><span class="sh">'</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></table></code></div></div><p>返回值是一个list，是每一类的召回率</p><p>参数:</p><p>average : string, [None, ‘micro’, ‘macro’(default), ‘samples’, ‘weighted’]</p><p>将一个二分类matrics拓展到多分类或多标签问题时，我们可以将数据看成多个二分类问题的集合，每个类都是一个二分类。接着，我们可以通过跨多个分类计算每个二分类metrics得分的均值，这在一些情况下很有用。你可以使用average参数来指定。</p><ul><li><p>macro：计算二分类metrics的均值，为每个类给出相同权重的分值。当小类很重要时会出问题，因为该macro-averging方法是对性能的平均。另一方面，该方法假设所有分类都是一样重要的，因此macro-averaging方法会对小类的性能影响很大。</p><li><p>weighted:对于不均衡数量的类来说，计算二分类metrics的平均，通过在每个类的score上进行加权实现。</p><li><p>micro：给出了每个样本类以及它对整个metrics的贡献的pair（sample-weight），而非对整个类的metrics求和，它会每个类的metrics上的权重及因子进行求和，来计算整个份额。Micro-averaging方法在多标签（multilabel）问题中设置，包含多分类，此时，大类将被忽略。</p><li><p>samples：应用在multilabel问题上。它不会计算每个类，相反，它会在评估数据中，通过计算真实类和预测类的差异的metrics，来求平均（sample_weight-weighted）</p><li><p>average：average=None将返回一个数组，它包含了每个类的得分.</p></ul><div class="language-terminal highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>from sklearn.metrics import recall_score
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y_true <span class="o">=</span> <span class="o">[</span>0, 1, 2, 0, 1, 2]
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y_pred <span class="o">=</span> <span class="o">[</span>0, 2, 1, 0, 0, 1]
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>recall_score<span class="o">(</span>y_true, y_pred, <span class="nv">average</span><span class="o">=</span><span class="s1">'macro'</span><span class="o">)</span> 
<span class="go">0.33...
</span><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>recall_score<span class="o">(</span>y_true, y_pred, <span class="nv">average</span><span class="o">=</span><span class="s1">'micro'</span><span class="o">)</span> 
<span class="go">0.33...
</span><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>recall_score<span class="o">(</span>y_true, y_pred, <span class="nv">average</span><span class="o">=</span><span class="s1">'weighted'</span><span class="o">)</span> 
<span class="go">0.33...
</span><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>recall_score<span class="o">(</span>y_true, y_pred, <span class="nv">average</span><span class="o">=</span>None<span class="o">)</span>
<span class="go">array([1.,  0., 0.])
</span></pre></table></code></div></div><h2 id="roc_curve"><strong>roc_curve</strong></h2><p>ROC曲线指受试者工作特征曲线/接收器操作特性(receiver operating characteristic，ROC)曲线,是反映灵敏性和特效性连续变量的综合指标,是用构图法揭示敏感性和特异性的相互关系，它通过将连续变量设定出多个不同的临界值，从而计算出一系列敏感性和特异性,roc曲线上每个点反映着对同一信号刺激的感受性。ROC曲线是根据一系列不同的二分类方式（分界值或决定阈），以真正例率（也就是灵敏度）（True Positive Rate,TPR）为纵坐标，假正例率（1-特效性）（False Positive Rate,FPR）为横坐标绘制的曲线。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/post/2021-09-13-detectionMetrics/1roc.png" alt="1" /> <em>图1</em></p><p>ROC观察模型正确地识别正例的比例与模型错误地把负例数据识别成正例的比例之间的权衡。TPR的增加以FPR的增加为代价。ROC曲线下的面积是模型准确率的度量，AUC（Area under roccurve）。</p><ul><li><p>TP : True Positive 预测为1，实际也为1</p><li><p>TN：True Nagetive 预测为0，实际也为0</p><li><p>FP：False Positive 预测为1，实际却为0</p><li><p>FN：False Nagetive 预测为0，实际却为1</p></ul>\[TPR=\frac{TP}{TP+FN}=Precison\] \[FPR=\frac{FP}{FP+TN}\]<p>具体到识别任务中就是，ROC曲线上的每一点反映的是不同的阈值对应的FP（false positive）和TP（true positive）之间的关系。通常情况下，ROC曲线越靠近（0，1）坐标（左上角）表示性能越好。</p><p><strong>纵坐标</strong>：真正类率（True Positive Rate , TPR）或灵敏度（sensitivity）。预测为正且实际为正的样本占所有正例样本的比例。</p><p>TPR = TP /（TP + FN） （正样本预测结果数 / 正样本实际数）</p><p><strong>横坐标</strong>：假正率（False Positive Rate , FPR），预测为正但实际为负的样本占所有负例样本的比例；(1-Specificity)</p><p>FPR = FP /（FP + TN） （被预测为正的负样本结果数 /负样本实际数）</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="nf">roc_curve</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span><span class="n">y_score</span><span class="p">,</span> <span class="n">pos_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">drop_intermediate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></table></code></div></div><p>该函数返回这三个变量：fpr，tpr，和阈值thresholds；</p><p>这里理解thresholds:</p><p>分类器的一个重要功能“概率输出”，即表示分类器认为某个样本具有多大的概率属于正样本（或负样本）。</p><p>“Score”表示每个测试样本属于正样本的概率。</p><p>接下来，我们从高到低，依次将“Score”值作为阈值threshold，当测试样本属于正样本的概率大于或等于这个threshold时，我们认为它为正样本，否则为负样本。每次选取一个不同的threshold，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。当我们将threshold设置为1和0时，分别可以得到ROC曲线上的(0,0)和(1,1)两个点。将这些(FPR,TPR)对连接起来，就得到了ROC曲线。当threshold取值越多，ROC曲线越平滑。其实，我们并不一定要得到每个测试样本是正样本的概率值，只要得到这个分类器对该测试样本的“评分值”即可（评分值并不一定在(0,1)区间）。评分越高，表示分类器越肯定地认为这个测试样本是正样本，而且同时使用各个评分值作为threshold。我认为将评分值转化为概率更易于理解一些。</p><div class="language-terminal highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>import numpy as np
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>from sklearn import metrics
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y <span class="o">=</span> np.array<span class="o">([</span>1, 1, 2, 2]<span class="o">)</span>
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>scores <span class="o">=</span> np.array<span class="o">([</span>0.1, 0.4, 0.35, 0.8]<span class="o">)</span>
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>fpr, tpr, thresholds <span class="o">=</span> metrics.roc_curve<span class="o">(</span>y, scores, <span class="nv">pos_label</span><span class="o">=</span>2<span class="o">)</span>
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>fpr
<span class="go">array([0. ,  0.5,  0.5, 1. ])
</span><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>tpr
<span class="go">array([0.5,  0.5,  1. , 1. ])
</span><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>thresholds
<span class="go">array([0.8 ,  0.4 ,  0.35, 0.1 ])
</span><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>from sklearn.metrics import auc 
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>metrics.auc<span class="o">(</span>fpr, tpr<span class="o">)</span> 
<span class="go">0.75 
</span></pre></table></code></div></div><h2 id="auc"><strong>Auc</strong></h2><p>AUC (Area Under Curve) 被定义为ROC曲线下的面积，显然这个面积的数值不会大于1。又由于ROC曲线一般都处于y=x这条直线的上方，所以AUC的取值范围一般在0.5和1之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，而作为一个数值，对应AUC更大的分类器效果更好。</p><ul><li><p>AUC = 1，是完美分类器，采用这个预测模型时，存在至少一个阈值能得出完美预测。绝大多数预测的场合，不存在完美分类器。</p><li><p>0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。</p><li><p>AUC = 0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。</p><li><p>AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。</p></ul><p>计算AUC值，其中x,y分别为数组形式，根据(xi,yi)在坐标上的点，生成的曲线，然后计算AUC值；</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="nf">auc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reorder</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="roc_auc_score"><strong>roc_auc_score</strong></h2><p>直接根据真实值（必须是二值）、预测值（可以是0/1,也可以是proba值）计算出auc值，中间过程的roc计算省略。</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="nf">roc_auc_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_score</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="sh">'</span><span class="s">macro</span><span class="sh">'</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></table></code></div></div><p>average : string, [None, ‘micro’, ‘macro’(default), ‘samples’, ‘weighted’]</p><div class="language-terminal highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>import numpy as np
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>from sklearn.metrics import roc_auc_score
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y_true <span class="o">=</span> np.array<span class="o">([</span>0, 0, 1, 1]<span class="o">)</span>
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y_scores <span class="o">=</span> np.array<span class="o">([</span>0.1, 0.4, 0.35, 0.8]<span class="o">)</span>
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>roc_auc_score<span class="o">(</span>y_true, y_scores<span class="o">)</span>
<span class="go">0.75
</span></pre></table></code></div></div><h2 id="混淆矩阵confusion_matrix"><strong>混淆矩阵confusion_matrix</strong></h2><p>假设有一个用来对猫（cats）、狗（dogs）、兔子（rabbits）进行分类的系统，混淆矩阵就是为了进一步分析性能而对该算法测试结果做出的总结。假设总共有 27 只动物：8只猫， 6条狗， 13只兔子。结果的混淆矩阵如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/post/2021-09-13-detectionMetrics/2confusionMat.png" alt="1" /> <em>图2</em></p><p>在这个混淆矩阵中，实际有 8只猫，但是系统将其中3只预测成了狗；对于 6条狗，其中有 1条被预测成了兔子，2条被预测成了猫。从混淆矩阵中我们可以看出系统对于区分猫和狗存在一些问题，但是区分兔子和其他动物的效果还是不错的。所有正确的预测结果都在对角线上，所以从混淆矩阵中可以很方便直观的看出哪里有错误，因为他们呈现在对角线外面。</p><div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="nf">confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></table></code></div></div><p>返回一个混淆矩阵；</p><p>labels：混淆矩阵的索引（如上面猫狗兔的示例），如果没有赋值，则按照y_true, y_pred中出现过的值排序。</p><div class="language-terminal highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>from sklearn.metrics import confusion_matrix
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y_true <span class="o">=</span> <span class="o">[</span>2, 0, 2, 2, 0, 1]
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y_pred <span class="o">=</span> <span class="o">[</span>0, 0, 2, 2, 0, 2]
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>confusion_matrix<span class="o">(</span>y_true, y_pred<span class="o">)</span>
<span class="go">array([[2,0, 0],
     [0, 0, 1],
     [1, 0, 2]])

</span><span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y_true <span class="o">=</span> <span class="o">[</span><span class="s2">"cat"</span>, <span class="s2">"ant"</span>, <span class="s2">"cat"</span>, <span class="s2">"cat"</span>,<span class="s2">"ant"</span>, <span class="s2">"bird"</span><span class="o">]</span>
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>y_pred <span class="o">=</span> <span class="o">[</span><span class="s2">"ant"</span>, <span class="s2">"ant"</span>, <span class="s2">"cat"</span>, <span class="s2">"cat"</span>,<span class="s2">"ant"</span>, <span class="s2">"cat"</span><span class="o">]</span>
<span class="gp">&gt;</span><span class="o">&gt;&gt;</span>confusion_matrix<span class="o">(</span>y_true, y_pred, <span class="nv">labels</span><span class="o">=[</span><span class="s2">"ant"</span>, <span class="s2">"bird"</span>,<span class="s2">"cat"</span><span class="o">])</span>
<span class="go">array([[2,0, 0],
      [0, 0, 1],
      [1, 0, 2]])
</span></pre></table></code></div></div><h2 id="f-score"><strong>F-score</strong></h2><p>用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的准确率和召回率，综合权衡Precision和Recall。因为Precision和Recall是对立关系的，一般情况下，Precision高，Recall就低；Recall高，Precision就低。在实际中常常需要根据具体情况做出取舍，例如一般的搜索情况，在保证召回率的条件下，尽量提升精确率。</p>\[F-score=\left( 1+{ {\beta }^{2}} \right)\centerdot \frac{Precison\centerdot Recall}{ { {\beta }^{2}}\centerdot Precison+Recall}\]<p>当β=1时，称为F1-score，这时，精确率和召回率都很重要，权重相同。当有些情况下，我们认为精确率更重要些，那就调整β的值小于1，如果我们认为召回率更重要些，那就调整β的值大于1。</p>\[{ {F}_{1}}=2\centerdot \frac{Precison\centerdot Recall}{Precison+Recall}\]<p>F1值为算数平均数除以几何平均数，且越大越好，将Precision和Recall的上述公式带入会发现，当F1值小时，True Positive相对增加，而false相对减少，即Precision和Recall都相对增加，即F1对Precision和Recall都进行了加权。</p>\[\frac{1}{ { {F}_{1}}}=\frac{1}{Precison}\text{+}\frac{1}{Recall}\]<p>公式转化之后为：</p>\[{ {F}_{1}}=\frac{2PR}{P+R}=\frac{2TP}{2TP+FP+FN}\]<div class="language-python highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">sklearn.metrics</span> <span class="kn">import</span> <span class="n">f1_score</span>
<span class="nf">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_predict</span><span class="p">)</span>
</pre></table></code></div></div><p>实际计算时，根据不同阈值，得到不同的Precision和Recall，而后通过上式计算F1 score，从而确定具体阈值，兼顾Precision和Recall。</p><h2 id="rank-n"><strong>Rank-n</strong></h2><p>Rank-n和mAP均是衡量算法搜索能力的指标。</p><p>搜索结果中最靠前（置信度最高）的n张图有正确结果的概率</p><p>rank 1， 就是第一次命中。</p><p>rank k，就是在第k次以内命中。</p><p>rank-5准确度是rank-1准确度的扩展，我们对一张图片的预测结果是来自模型输出结果中top5对应的5个预测，而不是top1的1个预测</p><p>当处理的大型数据集各个类别之间存在许多具有相似特征时，我们往往会增加一个rank-5准确度，也就是说我们不止关心rank-1准确度，也关心rank-5准确度。结合两个准确度来以衡量神经网络的性能。理想情况下，随着预测数据增加，希望rank-1准确度和rank-5准确度同比例增加。但是，在某些数据集上，情况往往并非总是如此。</p><p>因此，我们也根据rank-5准确度检验模型，以确保我们的网络在后面的迭代中仍然是“学习”的。在训练快结束时，rank-1准确度可能会停滞不前，但是当我们的网络学习到更多的识别特征(虽然没有足够的识别能力超过top1的预测)时，rank-5准确度会继续提高。</p><h2 id="平均精确度map"><strong>平均精确度mAP</strong></h2><p>mAP（mean Average Precision）即平均精确度的缩写。</p><p>先来看一下AP：所谓的AP，其实就是平均准确率。这里的平均是相对于不同验证集而言的。</p><p>假设我们想要训练一个猫分类器，如果是基于像素点级别的，那么就可以将它转换为一个二分类任务，那么它的mAP=正样本的准确率与负样本的准确率的平均值，多分类任务也可以如法炮制。</p><p>mAP这个性能指标对于数据不平衡问题就靠谱很多。假设我们有90%的正样本，10%的负样本，如果采用全部输出为正的分类器，那么P正=0.9,P负=0, 而mAP=0.45.</p><p>下面是几个在比较mAP值时需要记住的几个重点：</p><ul><li><p>1、 mAP需要计算完整个数据集；</p><li><p>2、 虽然模型输出的绝对量化是难以解释的，但mAP可以通过一个很好的相关性标准来帮助我们。当我们在流行的公开数据集上计算这个标准时，它可以很容易地用来比较目标检测的新旧方法。</p><li><p>3、 根据类别在训练集上的分布方式，AP值可能在某些类别上从很高（这有很好的训练数据）变化到很低（对数据很少或不好的类别）。所以你的mAP可能是合适的，但你的模型可能对某些类别非常好而对某些类别非常差。因此当分析你的模型结果时，观察独立类别的AP是明智的。这些值可能作为添加更多训练样本的指示器。</p></ul><p>一般目标检测任务中，使用IoU判断是否检测正确。IoU&gt;0.5，则认为检测的正确；否则认为检测错误。得到每个目标实际的IoU后，根据检测到的目标的置信度confidence，计算相应的Precision（纵坐标）和Recall（横坐标），得到xy坐标系上的曲线。并通过下式计算AP（当前点的Recall和下一个点的Recall之差，乘以当前点的Precision，而后求和。要给Recall和Precison分别添加0和1到最后）</p>\[\begin{align} &amp; AP=\sum\limits_{k=0}^{k=n-1}{\left[ Recalls\left( k \right)-Recalls\left( k+1 \right) \right]*Precisions\left( k \right)} \\ &amp; \quad \quad \quad \quad \quad Recalls\left( n \right)=0, \quad Precisions\left( n \right)=1 \\ &amp; \quad \quad \quad \quad \quad n=Number\text{ }of\text{ }thresholds \\ \end{align}\]<p>即AP为Precision-Recall曲线下方的面积：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/post/2021-09-13-detectionMetrics/3PRcurve.png" alt="1" /> <em>图3</em></p><p>非VOC2007的算法：对于某类下全部的真实目标，将IOU&gt;=0.5 的作为检测出来的目标，取不同的confidence 阈值计算对应的precision 和recall，对于每个recall，取其对应的最大precision，对这些precision 求平均即为该类的AP 值。所有类的AP 值求平均即为mAP。</p><p>VOC2007的算法：取[0, 0.1, 0.2, 0.3, ……, 1]作为confidence 阈值计算precision 和recall，其余同上。</p><p>在评测时，COCO评估了在不同的交并比(IoU)[0.5:0.05:0.95]共10个IoU下的AP，并且在最后以这些阈值下的AP平均作为结果，记为mAP@[.5, .95]。</p><p>而在Pascal VOC中，检测结果只评测了IOU在0.5这个阈值下的AP值。</p><p>因此相比VOC而言，COCO数据集的评测会更加全面：不仅评估到物体检测模型的分类能力，同时也能体现出检测模型的定位能力。因此在IoU较大如0.8时，预测框必须和真实的框具有很大的重叠比才能被视为正确。</p><h2 id="累积匹配曲线cmc"><strong>累积匹配曲线CMC</strong></h2><p>CMC曲线全称是Cumulative Match Characteristic (CMC) curve，也就是累积匹配曲线。</p><p>CMC曲线综合反映了分类器的性能，它的评价指标与现在deep learning中常用的top1 err或top5 err评价指标一样的意思，不同的是这里Rank1 recognition rate表示的是正确率而不是错误率，两者的关系是</p><p>Rank1识别率=1-top1 err</p><p>Rank5识别率=1-top5 ert</p><p>CMC将再识别问题看成是一种排序问题，CMC 曲线的具体含义是指：在候选行人库(gallery)中检索待查询(probe)的行人，前r个检索结果中包含正确匹配结果的比率。其中，第 1 匹配率 r=1 指标rank-1反映了最匹配候选目标刚好为待查询图片目标的概率，即该指标为真正的识别能力，因此很重要。但是当 r 值很小但大于1时，由于可以通过人眼进行辅助识别查找目标，因此也很有现实意义，如第 5 匹配率 r=5 指标反映前5个匹配候选目标中存在待查询图片目标的概率，如下图：横坐标表示排名等级r，纵坐标表示识别的准确率。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/post/2021-09-13-detectionMetrics/4CMC.png" alt="1" /> <em>图4</em></p><h2 id="single-shot和muti-shot"><strong>Single shot和Muti shot</strong></h2><p>前者是指gallery中每个人的图像为一张（N=1），而后者是指gallery中每个人的图像为N&gt;1张图像，同样的Rank-1下，一般N越大，得到的识别率越高。</p></div><div class="post-tail-wrapper text-muted"><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div class="post-tags"> <span>标签(Tags)</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a href="/tags/detection/" class="post-tag no-text-decoration" >detection</a></div></div><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/UbuntuAgent/">Ubuntu使用代理</a><li><a href="/posts/SunloginDisconnectWin10/">windows10使用向日葵访问ubuntu 20.04显示连接已断开</a><li><a href="/posts/TimeWin10Ubuntu/">windows10和ubuntu双系统的时间差</a><li><a href="/posts/markdown/">markdown基本语法</a><li><a href="/posts/MountDriverInWin10Ubuntu/">windows10的ubuntu子系统挂载移动硬盘</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/deep-learning/">deep learning</a> <a class="post-tag" href="/tags/detection/">detection</a> <a class="post-tag" href="/tags/normalization/">normalization</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/transformers/">transformers</a> <a class="post-tag" href="/tags/demo/">demo</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h6 align="left"><br>未设置提醒，因而不一定能看到回复，见谅</h6><div class="post-navigation d-flex justify-content-between"> <a href="/posts/markdown/" class="btn btn-outline-primary" prompt="Older"><p>markdown基本语法</p></a> <a href="/posts/fasterRCNN/" class="btn btn-outline-primary" prompt="Newer"><p>Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks</p></a></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> <script src="https://code.jquery.com/jquery-3.2.0.min.js"></script> <script>AV.initialize("7DUQTBuCCKLjnutJOa6ko5cn-MdYXbMMI", "lxmthTQ8ESa2HrVQiIVyXtYo");</script> <script> //新增访问次数 function addCount(Counter) { // 页面（博客文章）中的信息：leancloud_visitors // id为page.url， data-flag-title为page.title var $visitors = $(".leancloud_visitors"); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); var query = new AV.Query(Counter); // 只根据文章的url查询LeanCloud服务器中的数据 query.equalTo("post_url", url); query.find({ success: function(results) { if (results.length > 0) {//说明LeanCloud中已经记录了这篇文章 var counter = results[0]; counter.fetchWhenSave(true); counter.increment("visited_times");// 将点击次数加1 counter.save(null, { success: function(counter) { var $element = $(document.getElementById(url)); var newTimes = counter.get('visited_times'); $element.find('.leancloud-visitors-count').text(newTimes); }, error: function(counter, error) { console.log('Failed to save Visitor num, with error message: ' + error.message); } }); } else { // 执行这里，说明LeanCloud中还没有记录此文章 var newcounter = new Counter(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newcounter.setACL(acl); /* End Set ACL */ newcounter.set("post_title", title);// 把文章标题 newcounter.set("post_url", url); // 文章url newcounter.set("visited_times", 1); // 初始点击次数：1次 newcounter.save(null, { // 上传到LeanCloud服务器中 success: function(newcounter) { var $element = $(document.getElementById(url)); var newTimes = newcounter.get('visited_times'); $element.find('.leancloud-visitors-count').text(newTimes); }, error: function(newcounter, error) { console.log('Failed to create'); } }); } }, error: function(error) { console.log('Error:' + error.code + " " + error.message); } }); } //仅根据url和title查出当前访问次数，不做+1操作 function showCount(Counter) { var $visitors = $(".leancloud_visitors"); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); var query = new AV.Query(Counter); // 只根据文章的url查询LeanCloud服务器中的数据 query.equalTo("post_url", url); query.find({ success: function(results) { if (results.length > 0) {//说明LeanCloud中已经记录了这篇文章 var counter = results[0]; var $element = $(document.getElementById(url)); var newTimes = counter.get('visited_times'); $element.find('.leancloud-visitors-count').text(newTimes); } else { //如果表里没查到记录，那就是异常情况了 console.log('异常情况，不应该没记录的'); } }, error: function(error) { console.log('Error:' + error.code + " " + error.message); } }); } //调用API获取IP function getVisitorIpAndJudge() { var ip; var options = { type: 'POST', dataType: "json", //async: false, //jquery3中可以直接使用回调函数，不用再指定async url: "https://freegeoip.net/json/?callback=?" }; $.ajax(options) .done(function(data, textStatus, jqXHR) { if(textStatus == "success") { ip = data.ip; } judgeVisitor(ip) }); } //判断访客是否已访问过该文章，及访问时间，符合条件则增加一次访问次数 function judgeVisitor(ip) { var Counter = AV.Object.extend("visited_times"); var Visitor = AV.Object.extend("visitors_record"); var $postInfo = $(".leancloud_visitors"); var post_url = $postInfo.attr('id').trim(); var query = new AV.Query(Visitor); query.equalTo("visitor_ip", ip); query.equalTo("post_url", post_url); query.find({ success: function(results) { if (results.length > 0) { console.log('该IP已访问过该文章'); var oldVisitor = results[0]; var lastTime = oldVisitor.updatedAt; var curTime = new Date(); var timePassed = curTime.getTime() - lastTime.getTime(); if(timePassed > 1 * 60 * 1000) { console.log('距离该IP上一次访问该文章已超过了1分钟，更新访问记录，并增加访问次数'); addCount(Counter); oldVisitor.fetchWhenSave(true); oldVisitor.save(null, { success: function(oldVisitor) { }, error: function(oldVisitor, error) { console.log('Failed to save visitor record, with error message: ' + error.message); } }); } else { console.log('这是该IP 1分钟内重复访问该文章，不更新访问记录，不增加访问次数'); showCount(Counter); } } else { console.log('该IP第一次访问该文章，保存新的访问记录，并增加访问次数'); addCount(Counter); var newVisitor = new Visitor(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); newVisitor.setACL(acl); newVisitor.set("visitor_ip", ip); newVisitor.set("post_url", post_url); newVisitor.save(null, { // 上传到LeanCloud服务器中 success: function(newVisitor) { }, error: function(newVisitor, error) { console.log('Failed to create visitor record, with error message: ' + error.message); } }); } }, error: function(error) { console.log('Error:' + error.code + " " + error.message); addCount(Counter); } }); } $(function() { if ($('.leancloud_visitors').length == 1) { // 文章页面，调用判断方法，对符合条件的访问增加访问次数 getVisitorIpAndJudge(); } else if ($('.post-link').length > 1){ // 首页 暂未使用 // showHitCount(Counter); } }); </script><div> <span id="/posts/detectionMetrics/" class="leancloud_visitors" data-flag-title="目标检测中的一些评价参数"> <a href="#">Pageviews:<span class="leancloud-visitors-count"></span> times</a></span></div><h4 align="left">用户留言：</h4><div id="comments"></div><script src='//unpkg.com/valine/dist/Valine.min.js'></script> <script> new Valine({ av: AV, el: '#comments', app_id: '7DUQTBuCCKLjnutJOa6ko5cn-MdYXbMMI', app_key: 'lxmthTQ8ESa2HrVQiIVyXtYo', placeholder: '', avatar: 'mp', notify: 'true', verify: 'true', recordIP: 'true', enableQQ: 'true', visitor: true }); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#main > div.row:first-child > div:first-child img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="">darkknightzh</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/deep-learning/">deep learning</a> <a class="post-tag" href="/tags/detection/">detection</a> <a class="post-tag" href="/tags/normalization/">normalization</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/transformers/">transformers</a> <a class="post-tag" href="/tags/demo/">demo</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://darkknightzh.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
